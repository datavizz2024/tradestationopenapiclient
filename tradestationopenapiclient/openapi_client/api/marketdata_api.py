# coding: utf-8

"""
    

    # Authentication For more information on authorization and gaining an access/refresh token, please visit: [Authentication](/docs/fundamentals/authentication/auth-overview). <SecurityDefinitions /> 

    The version of the OpenAPI document: 
    Contact: ClientServices@tradestation.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, conint

from typing import List, Optional

from openapi_client.models.symbol_search_definition_inner import SymbolSearchDefinitionInner
from openapi_client.models.symbol_suggest_definition_inner import SymbolSuggestDefinitionInner
from openapi_client.models.tickbar_definition import TickbarDefinition

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class MarketdataApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def search_symbols(self, criteria : Annotated[StrictStr, Field(..., description="Criteria are represented as Key/value pairs (`&` separated):  `N`: Name of Symbol. (Optional)  `C`: Asset categories. (Optional) Possible values:   - `Future` or `FU`   - `FutureOption` or `FO`   - `Stock` or `S` (Default)   - `StockOption` or `SO` (If root is specified, default category)   - `Index` or `IDX`   - `CurrencyOption` or `CO`   - `MutualFund` or `MF`   - `MoneyMarketFund` or `MMF`   - `IndexOption` or `IO`   - `Bond` or `B`   - `Forex` or `FX`  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Equities Lookups:  `N`: partial/full symbol name, will return all symbols that contain the provided name value  `Desc`: Name of the company  `Flg`: indicates whether symbols no longer trading should be included in the results returned. (Optional) This criteria is not returned in the symbol data. Possible values:   - `true`   - `false` (Default)  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Options Lookups: (Category=StockOption, IndexOption, FutureOption or CurrencyOption)  `R`: Symbol root. Required field, the symbol the option is a derivative of, this search will not return options based on a partial root.  `Stk`: Number of strikes prices above and below the underlying price   - Default value 3  `Spl`: Strike price low  `Sph`: Strike price high  `Exd`: Number of expiration dates.   - Default value 3  `Edl`: Expiration date low, ex: 01-05-2011  `Edh`: Expiration date high, ex: 01-20-2011  `OT`: Option type. Possible values:   - `Both` (Default)   - `Call`   - `Put`  `FT`: Future type for FutureOptions. Possible values:   - `Electronic` (Default)   - `Pit`  `ST`: Symbol type: Possible values:   - `Both`   - `Composite` (Default)   - `Regional`  #### For Futures Lookups: (Category = Future)  `Desc`: Description of symbol traded  `R`: Symbol root future trades  `FT`: Futures type. Possible values:   - `None`   - `PIT`   - `Electronic` (Default)   - `Combined`  `Cur`: Currency. Possible values:   - `All`   - `USD` (Default)   - `AUD`   - `CAD`   - `CHF`   - `DKK`   - `EUR`   - `DBP`   - `HKD`   - `JPY`   - `NOK`   - `NZD`   - `SEK`   - `SGD`  `Exp`: whether to include expired contracts   - `false` (Default)   - `true`  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Forex Lookups:  `N`: partial/full symbol name. Use all or null for a list of all forex symbols  `Desc`: Description  Note:   - The exchange returned for all forex searches will be `FX`   - The country returned for all forex searches will be `FOREX` ")], **kwargs) -> List[SymbolSearchDefinitionInner]:  # noqa: E501
        """Search for Symbols   # noqa: E501

        Searches symbols based upon input criteria including Name, Category and Country.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_symbols(criteria, async_req=True)
        >>> result = thread.get()

        :param criteria: Criteria are represented as Key/value pairs (`&` separated):  `N`: Name of Symbol. (Optional)  `C`: Asset categories. (Optional) Possible values:   - `Future` or `FU`   - `FutureOption` or `FO`   - `Stock` or `S` (Default)   - `StockOption` or `SO` (If root is specified, default category)   - `Index` or `IDX`   - `CurrencyOption` or `CO`   - `MutualFund` or `MF`   - `MoneyMarketFund` or `MMF`   - `IndexOption` or `IO`   - `Bond` or `B`   - `Forex` or `FX`  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Equities Lookups:  `N`: partial/full symbol name, will return all symbols that contain the provided name value  `Desc`: Name of the company  `Flg`: indicates whether symbols no longer trading should be included in the results returned. (Optional) This criteria is not returned in the symbol data. Possible values:   - `true`   - `false` (Default)  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Options Lookups: (Category=StockOption, IndexOption, FutureOption or CurrencyOption)  `R`: Symbol root. Required field, the symbol the option is a derivative of, this search will not return options based on a partial root.  `Stk`: Number of strikes prices above and below the underlying price   - Default value 3  `Spl`: Strike price low  `Sph`: Strike price high  `Exd`: Number of expiration dates.   - Default value 3  `Edl`: Expiration date low, ex: 01-05-2011  `Edh`: Expiration date high, ex: 01-20-2011  `OT`: Option type. Possible values:   - `Both` (Default)   - `Call`   - `Put`  `FT`: Future type for FutureOptions. Possible values:   - `Electronic` (Default)   - `Pit`  `ST`: Symbol type: Possible values:   - `Both`   - `Composite` (Default)   - `Regional`  #### For Futures Lookups: (Category = Future)  `Desc`: Description of symbol traded  `R`: Symbol root future trades  `FT`: Futures type. Possible values:   - `None`   - `PIT`   - `Electronic` (Default)   - `Combined`  `Cur`: Currency. Possible values:   - `All`   - `USD` (Default)   - `AUD`   - `CAD`   - `CHF`   - `DKK`   - `EUR`   - `DBP`   - `HKD`   - `JPY`   - `NOK`   - `NZD`   - `SEK`   - `SGD`  `Exp`: whether to include expired contracts   - `false` (Default)   - `true`  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Forex Lookups:  `N`: partial/full symbol name. Use all or null for a list of all forex symbols  `Desc`: Description  Note:   - The exchange returned for all forex searches will be `FX`   - The country returned for all forex searches will be `FOREX`  (required)
        :type criteria: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[SymbolSearchDefinitionInner]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the search_symbols_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.search_symbols_with_http_info(criteria, **kwargs)  # noqa: E501

    @validate_arguments
    def search_symbols_with_http_info(self, criteria : Annotated[StrictStr, Field(..., description="Criteria are represented as Key/value pairs (`&` separated):  `N`: Name of Symbol. (Optional)  `C`: Asset categories. (Optional) Possible values:   - `Future` or `FU`   - `FutureOption` or `FO`   - `Stock` or `S` (Default)   - `StockOption` or `SO` (If root is specified, default category)   - `Index` or `IDX`   - `CurrencyOption` or `CO`   - `MutualFund` or `MF`   - `MoneyMarketFund` or `MMF`   - `IndexOption` or `IO`   - `Bond` or `B`   - `Forex` or `FX`  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Equities Lookups:  `N`: partial/full symbol name, will return all symbols that contain the provided name value  `Desc`: Name of the company  `Flg`: indicates whether symbols no longer trading should be included in the results returned. (Optional) This criteria is not returned in the symbol data. Possible values:   - `true`   - `false` (Default)  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Options Lookups: (Category=StockOption, IndexOption, FutureOption or CurrencyOption)  `R`: Symbol root. Required field, the symbol the option is a derivative of, this search will not return options based on a partial root.  `Stk`: Number of strikes prices above and below the underlying price   - Default value 3  `Spl`: Strike price low  `Sph`: Strike price high  `Exd`: Number of expiration dates.   - Default value 3  `Edl`: Expiration date low, ex: 01-05-2011  `Edh`: Expiration date high, ex: 01-20-2011  `OT`: Option type. Possible values:   - `Both` (Default)   - `Call`   - `Put`  `FT`: Future type for FutureOptions. Possible values:   - `Electronic` (Default)   - `Pit`  `ST`: Symbol type: Possible values:   - `Both`   - `Composite` (Default)   - `Regional`  #### For Futures Lookups: (Category = Future)  `Desc`: Description of symbol traded  `R`: Symbol root future trades  `FT`: Futures type. Possible values:   - `None`   - `PIT`   - `Electronic` (Default)   - `Combined`  `Cur`: Currency. Possible values:   - `All`   - `USD` (Default)   - `AUD`   - `CAD`   - `CHF`   - `DKK`   - `EUR`   - `DBP`   - `HKD`   - `JPY`   - `NOK`   - `NZD`   - `SEK`   - `SGD`  `Exp`: whether to include expired contracts   - `false` (Default)   - `true`  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Forex Lookups:  `N`: partial/full symbol name. Use all or null for a list of all forex symbols  `Desc`: Description  Note:   - The exchange returned for all forex searches will be `FX`   - The country returned for all forex searches will be `FOREX` ")], **kwargs) -> ApiResponse:  # noqa: E501
        """Search for Symbols   # noqa: E501

        Searches symbols based upon input criteria including Name, Category and Country.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_symbols_with_http_info(criteria, async_req=True)
        >>> result = thread.get()

        :param criteria: Criteria are represented as Key/value pairs (`&` separated):  `N`: Name of Symbol. (Optional)  `C`: Asset categories. (Optional) Possible values:   - `Future` or `FU`   - `FutureOption` or `FO`   - `Stock` or `S` (Default)   - `StockOption` or `SO` (If root is specified, default category)   - `Index` or `IDX`   - `CurrencyOption` or `CO`   - `MutualFund` or `MF`   - `MoneyMarketFund` or `MMF`   - `IndexOption` or `IO`   - `Bond` or `B`   - `Forex` or `FX`  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Equities Lookups:  `N`: partial/full symbol name, will return all symbols that contain the provided name value  `Desc`: Name of the company  `Flg`: indicates whether symbols no longer trading should be included in the results returned. (Optional) This criteria is not returned in the symbol data. Possible values:   - `true`   - `false` (Default)  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Options Lookups: (Category=StockOption, IndexOption, FutureOption or CurrencyOption)  `R`: Symbol root. Required field, the symbol the option is a derivative of, this search will not return options based on a partial root.  `Stk`: Number of strikes prices above and below the underlying price   - Default value 3  `Spl`: Strike price low  `Sph`: Strike price high  `Exd`: Number of expiration dates.   - Default value 3  `Edl`: Expiration date low, ex: 01-05-2011  `Edh`: Expiration date high, ex: 01-20-2011  `OT`: Option type. Possible values:   - `Both` (Default)   - `Call`   - `Put`  `FT`: Future type for FutureOptions. Possible values:   - `Electronic` (Default)   - `Pit`  `ST`: Symbol type: Possible values:   - `Both`   - `Composite` (Default)   - `Regional`  #### For Futures Lookups: (Category = Future)  `Desc`: Description of symbol traded  `R`: Symbol root future trades  `FT`: Futures type. Possible values:   - `None`   - `PIT`   - `Electronic` (Default)   - `Combined`  `Cur`: Currency. Possible values:   - `All`   - `USD` (Default)   - `AUD`   - `CAD`   - `CHF`   - `DKK`   - `EUR`   - `DBP`   - `HKD`   - `JPY`   - `NOK`   - `NZD`   - `SEK`   - `SGD`  `Exp`: whether to include expired contracts   - `false` (Default)   - `true`  `Cnt`: Country where the symbol is traded in. (Optional) Possible values:   - `ALL` if not specified (Default)   - `US`   - `DE`   - `CA`  #### For Forex Lookups:  `N`: partial/full symbol name. Use all or null for a list of all forex symbols  `Desc`: Description  Note:   - The exchange returned for all forex searches will be `FX`   - The country returned for all forex searches will be `FOREX`  (required)
        :type criteria: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[SymbolSearchDefinitionInner], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'criteria'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_symbols" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['criteria']:
            _path_params['criteria'] = _params['criteria']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "List[SymbolSearchDefinitionInner]",
            '400': "Error",
            '401': "Error",
            '403': "Error",
            '404': "Error",
            '500': "Error",
            '502': "Error",
            '504': "Error",
        }

        return self.api_client.call_api(
            '/v2/data/symbols/search/{criteria}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stream_tick_bars(self, symbol : Annotated[StrictStr, Field(..., description="A Symbol Name")], interval : Annotated[conint(strict=True, le=64999, ge=1), Field(..., description="Interval for each bar returned (in ticks).")], bars_back : Annotated[conint(strict=True, le=10, ge=1), Field(..., description="The number of bars to stream, going back from current time.")], **kwargs) -> TickbarDefinition:  # noqa: E501
        """Stream Tick Bars   # noqa: E501

        Streams tick bars data for the regular session from a number of bars back, each bar returned separated by interval number of ticks.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_tick_bars(symbol, interval, bars_back, async_req=True)
        >>> result = thread.get()

        :param symbol: A Symbol Name (required)
        :type symbol: str
        :param interval: Interval for each bar returned (in ticks). (required)
        :type interval: int
        :param bars_back: The number of bars to stream, going back from current time. (required)
        :type bars_back: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TickbarDefinition
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_tick_bars_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_tick_bars_with_http_info(symbol, interval, bars_back, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_tick_bars_with_http_info(self, symbol : Annotated[StrictStr, Field(..., description="A Symbol Name")], interval : Annotated[conint(strict=True, le=64999, ge=1), Field(..., description="Interval for each bar returned (in ticks).")], bars_back : Annotated[conint(strict=True, le=10, ge=1), Field(..., description="The number of bars to stream, going back from current time.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Tick Bars   # noqa: E501

        Streams tick bars data for the regular session from a number of bars back, each bar returned separated by interval number of ticks.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_tick_bars_with_http_info(symbol, interval, bars_back, async_req=True)
        >>> result = thread.get()

        :param symbol: A Symbol Name (required)
        :type symbol: str
        :param interval: Interval for each bar returned (in ticks). (required)
        :type interval: int
        :param bars_back: The number of bars to stream, going back from current time. (required)
        :type bars_back: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TickbarDefinition, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'symbol',
            'interval',
            'bars_back'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_tick_bars" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['symbol']:
            _path_params['symbol'] = _params['symbol']

        if _params['interval']:
            _path_params['interval'] = _params['interval']

        if _params['bars_back']:
            _path_params['barsBack'] = _params['bars_back']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "TickbarDefinition",
            '400': "Error",
            '401': "Error",
            '403': "Error",
            '404': "Error",
            '500': "Error",
            '502': "Error",
            '504': "Error",
        }

        return self.api_client.call_api(
            '/v2/stream/tickbars/{symbol}/{interval}/{barsBack}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def suggestsymbols(self, text : Annotated[StrictStr, Field(..., description="Symbol text for suggestion. Partial input of a symbol name, company name, or description.")], top : Annotated[Optional[StrictInt], Field(description="The top number of results to return.")] = None, filter : Annotated[Optional[StrictStr], Field(description="An OData filter to apply to the results. Supports the `eq` and `neq` filter opeators. E.g. `AAP?$filter=Category%20neq%20%27Stock%27`. Valid values are: `Category` (`Stock`, `Index`, `Future`, `Forex`), `Country` (E.g. `United States`, `GB`) `Currency` (E.g. `USD`, `AUD`), and `Exchange` (E.g. `NYSE`).")] = None, **kwargs) -> List[SymbolSuggestDefinitionInner]:  # noqa: E501
        """Suggest Symbols   # noqa: E501

        Suggests symbols semantically based upon partial input of symbol name, company name, or description. Does not return Options symbols.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.suggestsymbols(text, top, filter, async_req=True)
        >>> result = thread.get()

        :param text: Symbol text for suggestion. Partial input of a symbol name, company name, or description. (required)
        :type text: str
        :param top: The top number of results to return.
        :type top: int
        :param filter: An OData filter to apply to the results. Supports the `eq` and `neq` filter opeators. E.g. `AAP?$filter=Category%20neq%20%27Stock%27`. Valid values are: `Category` (`Stock`, `Index`, `Future`, `Forex`), `Country` (E.g. `United States`, `GB`) `Currency` (E.g. `USD`, `AUD`), and `Exchange` (E.g. `NYSE`).
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[SymbolSuggestDefinitionInner]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the suggestsymbols_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.suggestsymbols_with_http_info(text, top, filter, **kwargs)  # noqa: E501

    @validate_arguments
    def suggestsymbols_with_http_info(self, text : Annotated[StrictStr, Field(..., description="Symbol text for suggestion. Partial input of a symbol name, company name, or description.")], top : Annotated[Optional[StrictInt], Field(description="The top number of results to return.")] = None, filter : Annotated[Optional[StrictStr], Field(description="An OData filter to apply to the results. Supports the `eq` and `neq` filter opeators. E.g. `AAP?$filter=Category%20neq%20%27Stock%27`. Valid values are: `Category` (`Stock`, `Index`, `Future`, `Forex`), `Country` (E.g. `United States`, `GB`) `Currency` (E.g. `USD`, `AUD`), and `Exchange` (E.g. `NYSE`).")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Suggest Symbols   # noqa: E501

        Suggests symbols semantically based upon partial input of symbol name, company name, or description. Does not return Options symbols.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.suggestsymbols_with_http_info(text, top, filter, async_req=True)
        >>> result = thread.get()

        :param text: Symbol text for suggestion. Partial input of a symbol name, company name, or description. (required)
        :type text: str
        :param top: The top number of results to return.
        :type top: int
        :param filter: An OData filter to apply to the results. Supports the `eq` and `neq` filter opeators. E.g. `AAP?$filter=Category%20neq%20%27Stock%27`. Valid values are: `Category` (`Stock`, `Index`, `Future`, `Forex`), `Country` (E.g. `United States`, `GB`) `Currency` (E.g. `USD`, `AUD`), and `Exchange` (E.g. `NYSE`).
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[SymbolSuggestDefinitionInner], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'text',
            'top',
            'filter'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method suggestsymbols" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['text']:
            _path_params['text'] = _params['text']


        # process the query parameters
        _query_params = []
        if _params.get('top') is not None:  # noqa: E501
            _query_params.append(('$top', _params['top']))

        if _params.get('filter') is not None:  # noqa: E501
            _query_params.append(('$filter', _params['filter']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "List[SymbolSuggestDefinitionInner]",
            '400': "Error",
            '401': "Error",
            '403': "Error",
            '500': "Error",
            '502': "Error",
            '504': "Error",
        }

        return self.api_client.call_api(
            '/v2/data/symbols/suggest/{text}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
