# coding: utf-8

"""
    

    # Authentication For more information on authorization and gaining an access/refresh token, please visit: [Authentication](/docs/fundamentals/authentication/auth-overview). <SecurityDefinitions /> 

    The version of the OpenAPI document: 
    Contact: ClientServices@tradestation.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, conint

from typing import Optional

from openapi_client.models.accounts import Accounts
from openapi_client.models.balances import Balances
from openapi_client.models.balances_bod import BalancesBOD
from openapi_client.models.historical_orders import HistoricalOrders
from openapi_client.models.historical_orders_by_id import HistoricalOrdersById
from openapi_client.models.orders import Orders
from openapi_client.models.orders_by_id import OrdersById
from openapi_client.models.positions import Positions
from openapi_client.models.stream_orders200_response import StreamOrders200Response
from openapi_client.models.stream_orders_by_order_id200_response import StreamOrdersByOrderId200Response
from openapi_client.models.stream_positions200_response import StreamPositions200Response
from openapi_client.models.stream_wallets200_response import StreamWallets200Response
from openapi_client.models.wallets import Wallets

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class BrokerageApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def get_accounts(self, **kwargs) -> Accounts:  # noqa: E501
        """Get Accounts  # noqa: E501

        Fetches the list of Brokerage Accounts available for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Accounts
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_accounts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_accounts_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def get_accounts_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Accounts  # noqa: E501

        Fetches the list of Brokerage Accounts available for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accounts" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Accounts",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_balances(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], **kwargs) -> Balances:  # noqa: E501
        """Get Balances  # noqa: E501

        Fetches the brokerage account `Balances` for one or more given accounts. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_balances(accounts, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Balances
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_balances_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_balances_with_http_info(accounts, **kwargs)  # noqa: E501

    @validate_arguments
    def get_balances_with_http_info(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Balances  # noqa: E501

        Fetches the brokerage account `Balances` for one or more given accounts. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_balances_with_http_info(accounts, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Balances, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'accounts'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_balances" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['accounts']:
            _path_params['accounts'] = _params['accounts']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Balances",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts/{accounts}/balances', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_balances_bod(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], **kwargs) -> BalancesBOD:  # noqa: E501
        """Get Balances BOD  # noqa: E501

        Fetches the Beginning of Day Balances for the given Accounts. Request valid for `Cash`, `Margin`, `Futures`, and  `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_balances_bod(accounts, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BalancesBOD
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_balances_bod_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_balances_bod_with_http_info(accounts, **kwargs)  # noqa: E501

    @validate_arguments
    def get_balances_bod_with_http_info(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Balances BOD  # noqa: E501

        Fetches the Beginning of Day Balances for the given Accounts. Request valid for `Cash`, `Margin`, `Futures`, and  `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_balances_bod_with_http_info(accounts, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BalancesBOD, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'accounts'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_balances_bod" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['accounts']:
            _path_params['accounts'] = _params['accounts']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "BalancesBOD",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts/{accounts}/bodbalances', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_historical_orders(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], since : Annotated[StrictStr, Field(..., description="Historical orders since date. For example `\"2006-01-13\",\"01-13-2006\",\"2006/01/13\",\"01/13/2006\"`. Limited to 90 days prior to the current date.")], page_size : Annotated[Optional[conint(strict=True, le=600, ge=1)], Field(description="The number of requests returned per page when paginating responses. If not provided, results will not be paginated and a maximum of 600 orders is returned.")] = None, next_token : Annotated[Optional[StrictStr], Field(description="An encrypted token with a lifetime of 1 hour for use with paginated order responses. This is returned with paginated results, and used in only the subsequent request which will return a new nextToken until there are fewer returned orders than the requested pageSize. If the number of returned orders equals the pageSize, and there are no additional orders, the nextToken will not be generated.")] = None, **kwargs) -> HistoricalOrders:  # noqa: E501
        """Get Historical Orders  # noqa: E501

        Fetches Historical Orders for the given Accounts except open orders, sorted in descending order of time closed. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_historical_orders(accounts, since, page_size, next_token, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param since: Historical orders since date. For example `\"2006-01-13\",\"01-13-2006\",\"2006/01/13\",\"01/13/2006\"`. Limited to 90 days prior to the current date. (required)
        :type since: str
        :param page_size: The number of requests returned per page when paginating responses. If not provided, results will not be paginated and a maximum of 600 orders is returned.
        :type page_size: int
        :param next_token: An encrypted token with a lifetime of 1 hour for use with paginated order responses. This is returned with paginated results, and used in only the subsequent request which will return a new nextToken until there are fewer returned orders than the requested pageSize. If the number of returned orders equals the pageSize, and there are no additional orders, the nextToken will not be generated.
        :type next_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoricalOrders
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_historical_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_historical_orders_with_http_info(accounts, since, page_size, next_token, **kwargs)  # noqa: E501

    @validate_arguments
    def get_historical_orders_with_http_info(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], since : Annotated[StrictStr, Field(..., description="Historical orders since date. For example `\"2006-01-13\",\"01-13-2006\",\"2006/01/13\",\"01/13/2006\"`. Limited to 90 days prior to the current date.")], page_size : Annotated[Optional[conint(strict=True, le=600, ge=1)], Field(description="The number of requests returned per page when paginating responses. If not provided, results will not be paginated and a maximum of 600 orders is returned.")] = None, next_token : Annotated[Optional[StrictStr], Field(description="An encrypted token with a lifetime of 1 hour for use with paginated order responses. This is returned with paginated results, and used in only the subsequent request which will return a new nextToken until there are fewer returned orders than the requested pageSize. If the number of returned orders equals the pageSize, and there are no additional orders, the nextToken will not be generated.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Historical Orders  # noqa: E501

        Fetches Historical Orders for the given Accounts except open orders, sorted in descending order of time closed. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_historical_orders_with_http_info(accounts, since, page_size, next_token, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param since: Historical orders since date. For example `\"2006-01-13\",\"01-13-2006\",\"2006/01/13\",\"01/13/2006\"`. Limited to 90 days prior to the current date. (required)
        :type since: str
        :param page_size: The number of requests returned per page when paginating responses. If not provided, results will not be paginated and a maximum of 600 orders is returned.
        :type page_size: int
        :param next_token: An encrypted token with a lifetime of 1 hour for use with paginated order responses. This is returned with paginated results, and used in only the subsequent request which will return a new nextToken until there are fewer returned orders than the requested pageSize. If the number of returned orders equals the pageSize, and there are no additional orders, the nextToken will not be generated.
        :type next_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoricalOrders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'accounts',
            'since',
            'page_size',
            'next_token'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_historical_orders" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['accounts']:
            _path_params['accounts'] = _params['accounts']


        # process the query parameters
        _query_params = []
        if _params.get('since') is not None:  # noqa: E501
            _query_params.append(('since', _params['since']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('next_token') is not None:  # noqa: E501
            _query_params.append(('nextToken', _params['next_token']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "HistoricalOrders",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts/{accounts}/historicalorders', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_historical_orders_by_order_id(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], order_ids : Annotated[StrictStr, Field(..., description="List of valid Order IDs for the authenticated user for given accounts in comma separated format; for example `\"123456789,6B29FC40-CA47-1067-B31D-00DD010662DA\"`. 1 to 50 Order IDs can be specified, comma separated. Note, crypto order ids could exceed the URL path with limit for 50 orders ids.")], since : Annotated[StrictStr, Field(..., description="Historical orders since date. For example `\"2006-01-13\",\"01-13-2006\",\"2006/01/13\",\"01/13/2006\"`. Limited to 90 days prior to the current date.")], **kwargs) -> HistoricalOrdersById:  # noqa: E501
        """Get Historical Orders By Order ID  # noqa: E501

        Fetches Historical Orders for the given Accounts except open orders, filtered by given Order IDs prior to current date, sorted in descending order of time closed. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_historical_orders_by_order_id(accounts, order_ids, since, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param order_ids: List of valid Order IDs for the authenticated user for given accounts in comma separated format; for example `\"123456789,6B29FC40-CA47-1067-B31D-00DD010662DA\"`. 1 to 50 Order IDs can be specified, comma separated. Note, crypto order ids could exceed the URL path with limit for 50 orders ids. (required)
        :type order_ids: str
        :param since: Historical orders since date. For example `\"2006-01-13\",\"01-13-2006\",\"2006/01/13\",\"01/13/2006\"`. Limited to 90 days prior to the current date. (required)
        :type since: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HistoricalOrdersById
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_historical_orders_by_order_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_historical_orders_by_order_id_with_http_info(accounts, order_ids, since, **kwargs)  # noqa: E501

    @validate_arguments
    def get_historical_orders_by_order_id_with_http_info(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], order_ids : Annotated[StrictStr, Field(..., description="List of valid Order IDs for the authenticated user for given accounts in comma separated format; for example `\"123456789,6B29FC40-CA47-1067-B31D-00DD010662DA\"`. 1 to 50 Order IDs can be specified, comma separated. Note, crypto order ids could exceed the URL path with limit for 50 orders ids.")], since : Annotated[StrictStr, Field(..., description="Historical orders since date. For example `\"2006-01-13\",\"01-13-2006\",\"2006/01/13\",\"01/13/2006\"`. Limited to 90 days prior to the current date.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Historical Orders By Order ID  # noqa: E501

        Fetches Historical Orders for the given Accounts except open orders, filtered by given Order IDs prior to current date, sorted in descending order of time closed. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_historical_orders_by_order_id_with_http_info(accounts, order_ids, since, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param order_ids: List of valid Order IDs for the authenticated user for given accounts in comma separated format; for example `\"123456789,6B29FC40-CA47-1067-B31D-00DD010662DA\"`. 1 to 50 Order IDs can be specified, comma separated. Note, crypto order ids could exceed the URL path with limit for 50 orders ids. (required)
        :type order_ids: str
        :param since: Historical orders since date. For example `\"2006-01-13\",\"01-13-2006\",\"2006/01/13\",\"01/13/2006\"`. Limited to 90 days prior to the current date. (required)
        :type since: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HistoricalOrdersById, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'accounts',
            'order_ids',
            'since'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_historical_orders_by_order_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['accounts']:
            _path_params['accounts'] = _params['accounts']

        if _params['order_ids']:
            _path_params['orderIds'] = _params['order_ids']


        # process the query parameters
        _query_params = []
        if _params.get('since') is not None:  # noqa: E501
            _query_params.append(('since', _params['since']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "HistoricalOrdersById",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts/{accounts}/historicalorders/{orderIds}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_orders(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], page_size : Annotated[Optional[conint(strict=True, le=600, ge=1)], Field(description="The number of requests returned per page when paginating responses. If not provided, results will not be paginated and a maximum of 600 orders is returned.")] = None, next_token : Annotated[Optional[StrictStr], Field(description="An encrypted token with a lifetime of 1 hour for use with paginated order responses. This is returned with paginated results, and used in only the subsequent request which will return a new nextToken until there are fewer returned orders than the requested pageSize. If the number of returned orders equals the pageSize, and there are no additional orders, the nextToken will not be generated.")] = None, **kwargs) -> Orders:  # noqa: E501
        """Get Orders  # noqa: E501

        Fetches today's orders and open orders for the given Accounts, sorted in descending order of time placed for open and time executed for closed. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_orders(accounts, page_size, next_token, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param page_size: The number of requests returned per page when paginating responses. If not provided, results will not be paginated and a maximum of 600 orders is returned.
        :type page_size: int
        :param next_token: An encrypted token with a lifetime of 1 hour for use with paginated order responses. This is returned with paginated results, and used in only the subsequent request which will return a new nextToken until there are fewer returned orders than the requested pageSize. If the number of returned orders equals the pageSize, and there are no additional orders, the nextToken will not be generated.
        :type next_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Orders
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_orders_with_http_info(accounts, page_size, next_token, **kwargs)  # noqa: E501

    @validate_arguments
    def get_orders_with_http_info(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], page_size : Annotated[Optional[conint(strict=True, le=600, ge=1)], Field(description="The number of requests returned per page when paginating responses. If not provided, results will not be paginated and a maximum of 600 orders is returned.")] = None, next_token : Annotated[Optional[StrictStr], Field(description="An encrypted token with a lifetime of 1 hour for use with paginated order responses. This is returned with paginated results, and used in only the subsequent request which will return a new nextToken until there are fewer returned orders than the requested pageSize. If the number of returned orders equals the pageSize, and there are no additional orders, the nextToken will not be generated.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Orders  # noqa: E501

        Fetches today's orders and open orders for the given Accounts, sorted in descending order of time placed for open and time executed for closed. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_orders_with_http_info(accounts, page_size, next_token, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param page_size: The number of requests returned per page when paginating responses. If not provided, results will not be paginated and a maximum of 600 orders is returned.
        :type page_size: int
        :param next_token: An encrypted token with a lifetime of 1 hour for use with paginated order responses. This is returned with paginated results, and used in only the subsequent request which will return a new nextToken until there are fewer returned orders than the requested pageSize. If the number of returned orders equals the pageSize, and there are no additional orders, the nextToken will not be generated.
        :type next_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Orders, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'accounts',
            'page_size',
            'next_token'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_orders" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['accounts']:
            _path_params['accounts'] = _params['accounts']


        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('next_token') is not None:  # noqa: E501
            _query_params.append(('nextToken', _params['next_token']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Orders",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts/{accounts}/orders', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_orders_by_order_id(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], order_ids : Annotated[StrictStr, Field(..., description="List of valid Order IDs for the authenticated user for given accounts in comma separated format; for example `\"123456789,6B29FC40-CA47-1067-B31D-00DD010662DA\"`. 1 to 50 Order IDs can be specified, comma separated. Note, crypto order ids could exceed the URL path with limit for 50 orders ids.")], **kwargs) -> OrdersById:  # noqa: E501
        """Get Orders By Order ID  # noqa: E501

        Fetches today's orders and open orders for the given Accounts, filtered by given Order IDs, sorted in descending order of time placed for open and time executed for closed. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_orders_by_order_id(accounts, order_ids, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param order_ids: List of valid Order IDs for the authenticated user for given accounts in comma separated format; for example `\"123456789,6B29FC40-CA47-1067-B31D-00DD010662DA\"`. 1 to 50 Order IDs can be specified, comma separated. Note, crypto order ids could exceed the URL path with limit for 50 orders ids. (required)
        :type order_ids: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrdersById
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_orders_by_order_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_orders_by_order_id_with_http_info(accounts, order_ids, **kwargs)  # noqa: E501

    @validate_arguments
    def get_orders_by_order_id_with_http_info(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], order_ids : Annotated[StrictStr, Field(..., description="List of valid Order IDs for the authenticated user for given accounts in comma separated format; for example `\"123456789,6B29FC40-CA47-1067-B31D-00DD010662DA\"`. 1 to 50 Order IDs can be specified, comma separated. Note, crypto order ids could exceed the URL path with limit for 50 orders ids.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Orders By Order ID  # noqa: E501

        Fetches today's orders and open orders for the given Accounts, filtered by given Order IDs, sorted in descending order of time placed for open and time executed for closed. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_orders_by_order_id_with_http_info(accounts, order_ids, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param order_ids: List of valid Order IDs for the authenticated user for given accounts in comma separated format; for example `\"123456789,6B29FC40-CA47-1067-B31D-00DD010662DA\"`. 1 to 50 Order IDs can be specified, comma separated. Note, crypto order ids could exceed the URL path with limit for 50 orders ids. (required)
        :type order_ids: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrdersById, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'accounts',
            'order_ids'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_orders_by_order_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['accounts']:
            _path_params['accounts'] = _params['accounts']

        if _params['order_ids']:
            _path_params['orderIds'] = _params['order_ids']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "OrdersById",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts/{accounts}/orders/{orderIds}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_positions(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], symbol : Annotated[Optional[StrictStr], Field(description="List of valid symbols in comma separated format; for example `MSFT,MSFT *,BTCUSD`. You can use an * as wildcard to make more complex filters.  Examples of the wildcard being used:     * Get all options for MSFT: symbol=`MSFT *`   * Get MSFT and all its options: symbol=`MSFT,MSFT *`   * Get all MSFT options expiring in 2023: symbol=`MSFT 23*`   * Get all MSFT options expiring in March 2023: symbol=`MSFT 2303*`   * Get all options expiring in March 2023: symbol=`* 2303*`   * Get all call options expiring in March 2023: symbol=`* 2303*C*`   * Get BHM*: symbol=`BHM**`")] = None, **kwargs) -> Positions:  # noqa: E501
        """Get Positions  # noqa: E501

        Fetches positions for the given Accounts. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_positions(accounts, symbol, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param symbol: List of valid symbols in comma separated format; for example `MSFT,MSFT *,BTCUSD`. You can use an * as wildcard to make more complex filters.  Examples of the wildcard being used:     * Get all options for MSFT: symbol=`MSFT *`   * Get MSFT and all its options: symbol=`MSFT,MSFT *`   * Get all MSFT options expiring in 2023: symbol=`MSFT 23*`   * Get all MSFT options expiring in March 2023: symbol=`MSFT 2303*`   * Get all options expiring in March 2023: symbol=`* 2303*`   * Get all call options expiring in March 2023: symbol=`* 2303*C*`   * Get BHM*: symbol=`BHM**`
        :type symbol: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Positions
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_positions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_positions_with_http_info(accounts, symbol, **kwargs)  # noqa: E501

    @validate_arguments
    def get_positions_with_http_info(self, accounts : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10.")], symbol : Annotated[Optional[StrictStr], Field(description="List of valid symbols in comma separated format; for example `MSFT,MSFT *,BTCUSD`. You can use an * as wildcard to make more complex filters.  Examples of the wildcard being used:     * Get all options for MSFT: symbol=`MSFT *`   * Get MSFT and all its options: symbol=`MSFT,MSFT *`   * Get all MSFT options expiring in 2023: symbol=`MSFT 23*`   * Get all MSFT options expiring in March 2023: symbol=`MSFT 2303*`   * Get all options expiring in March 2023: symbol=`* 2303*`   * Get all call options expiring in March 2023: symbol=`* 2303*C*`   * Get BHM*: symbol=`BHM**`")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Positions  # noqa: E501

        Fetches positions for the given Accounts. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_positions_with_http_info(accounts, symbol, async_req=True)
        >>> result = thread.get()

        :param accounts: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. Recommended batch size is 10. (required)
        :type accounts: str
        :param symbol: List of valid symbols in comma separated format; for example `MSFT,MSFT *,BTCUSD`. You can use an * as wildcard to make more complex filters.  Examples of the wildcard being used:     * Get all options for MSFT: symbol=`MSFT *`   * Get MSFT and all its options: symbol=`MSFT,MSFT *`   * Get all MSFT options expiring in 2023: symbol=`MSFT 23*`   * Get all MSFT options expiring in March 2023: symbol=`MSFT 2303*`   * Get all options expiring in March 2023: symbol=`* 2303*`   * Get all call options expiring in March 2023: symbol=`* 2303*C*`   * Get BHM*: symbol=`BHM**`
        :type symbol: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Positions, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'accounts',
            'symbol'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_positions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['accounts']:
            _path_params['accounts'] = _params['accounts']


        # process the query parameters
        _query_params = []
        if _params.get('symbol') is not None:  # noqa: E501
            _query_params.append(('symbol', _params['symbol']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Positions",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts/{accounts}/positions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_wallets(self, account : Annotated[StrictStr, Field(..., description="A valid crypto Account ID for the authenticated user; for example `\"61999124C\"`.")], **kwargs) -> Wallets:  # noqa: E501
        """Get Wallets  # noqa: E501

        Fetches wallet information. Request valid for `Crypto` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_wallets(account, async_req=True)
        >>> result = thread.get()

        :param account: A valid crypto Account ID for the authenticated user; for example `\"61999124C\"`. (required)
        :type account: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wallets
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_wallets_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_wallets_with_http_info(account, **kwargs)  # noqa: E501

    @validate_arguments
    def get_wallets_with_http_info(self, account : Annotated[StrictStr, Field(..., description="A valid crypto Account ID for the authenticated user; for example `\"61999124C\"`.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Wallets  # noqa: E501

        Fetches wallet information. Request valid for `Crypto` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_wallets_with_http_info(account, async_req=True)
        >>> result = thread.get()

        :param account: A valid crypto Account ID for the authenticated user; for example `\"61999124C\"`. (required)
        :type account: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wallets, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_wallets" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account']:
            _path_params['account'] = _params['account']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Wallets",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/accounts/{account}/wallets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stream_orders(self, account_ids : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated.")], **kwargs) -> StreamOrders200Response:  # noqa: E501
        """Stream Orders  # noqa: E501

        Stream orders for the given accounts. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_orders(account_ids, async_req=True)
        >>> result = thread.get()

        :param account_ids: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. (required)
        :type account_ids: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamOrders200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_orders_with_http_info(account_ids, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_orders_with_http_info(self, account_ids : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Orders  # noqa: E501

        Stream orders for the given accounts. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_orders_with_http_info(account_ids, async_req=True)
        >>> result = thread.get()

        :param account_ids: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. (required)
        :type account_ids: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamOrders200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account_ids'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_orders" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_ids']:
            _path_params['accountIds'] = _params['account_ids']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v3+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "StreamOrders200Response",
            '400': "ErrorResponse1",
            '401': "ErrorResponse1",
            '403': "ErrorResponse1",
            '404': "ErrorResponse1",
            '429': "ErrorResponse1",
            '503': "ErrorResponse1",
            '504': "ErrorResponse1",
        }

        return self.api_client.call_api(
            '/v3/brokerage/stream/accounts/{accountIds}/orders', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stream_orders_by_order_id(self, account_ids : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 account IDs can be specified, comma separated.")], orders_ids : Annotated[StrictStr, Field(..., description="List of valid Order IDs for the account IDs in comma separated format; for example `\"812767578,812941051\"`. 1 to 50 order IDs can be specified, comma separated.")], **kwargs) -> StreamOrdersByOrderId200Response:  # noqa: E501
        """Stream Orders by Order Id  # noqa: E501

        Stream orders for the given accounts and orders. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_orders_by_order_id(account_ids, orders_ids, async_req=True)
        >>> result = thread.get()

        :param account_ids: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 account IDs can be specified, comma separated. (required)
        :type account_ids: str
        :param orders_ids: List of valid Order IDs for the account IDs in comma separated format; for example `\"812767578,812941051\"`. 1 to 50 order IDs can be specified, comma separated. (required)
        :type orders_ids: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamOrdersByOrderId200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_orders_by_order_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_orders_by_order_id_with_http_info(account_ids, orders_ids, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_orders_by_order_id_with_http_info(self, account_ids : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 account IDs can be specified, comma separated.")], orders_ids : Annotated[StrictStr, Field(..., description="List of valid Order IDs for the account IDs in comma separated format; for example `\"812767578,812941051\"`. 1 to 50 order IDs can be specified, comma separated.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Orders by Order Id  # noqa: E501

        Stream orders for the given accounts and orders. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_orders_by_order_id_with_http_info(account_ids, orders_ids, async_req=True)
        >>> result = thread.get()

        :param account_ids: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 account IDs can be specified, comma separated. (required)
        :type account_ids: str
        :param orders_ids: List of valid Order IDs for the account IDs in comma separated format; for example `\"812767578,812941051\"`. 1 to 50 order IDs can be specified, comma separated. (required)
        :type orders_ids: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamOrdersByOrderId200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account_ids',
            'orders_ids'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_orders_by_order_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_ids']:
            _path_params['accountIds'] = _params['account_ids']

        if _params['orders_ids']:
            _path_params['ordersIds'] = _params['orders_ids']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v3+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "StreamOrdersByOrderId200Response",
            '400': "ErrorResponse1",
            '401': "ErrorResponse1",
            '403': "ErrorResponse1",
            '404': "ErrorResponse1",
            '429': "ErrorResponse1",
            '503': "ErrorResponse1",
            '504': "ErrorResponse1",
        }

        return self.api_client.call_api(
            '/v3/brokerage/stream/accounts/{accountIds}/orders/{ordersIds}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stream_positions(self, account_ids : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated.")], changes : Annotated[Optional[StrictBool], Field(description="A boolean value that specifies whether or not position updates are streamed as changes. When a stream is first opened with `\"changes=true\"`, streaming positions will return the full snapshot first for all positions, and then any changes after that. When `\"changes=true\"`, the PositionID field is returned with each change, along with the fields that changed.")] = None, **kwargs) -> StreamPositions200Response:  # noqa: E501
        """Stream Positions  # noqa: E501

        Stream positions for the given accounts. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_positions(account_ids, changes, async_req=True)
        >>> result = thread.get()

        :param account_ids: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. (required)
        :type account_ids: str
        :param changes: A boolean value that specifies whether or not position updates are streamed as changes. When a stream is first opened with `\"changes=true\"`, streaming positions will return the full snapshot first for all positions, and then any changes after that. When `\"changes=true\"`, the PositionID field is returned with each change, along with the fields that changed.
        :type changes: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamPositions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_positions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_positions_with_http_info(account_ids, changes, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_positions_with_http_info(self, account_ids : Annotated[StrictStr, Field(..., description="List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated.")], changes : Annotated[Optional[StrictBool], Field(description="A boolean value that specifies whether or not position updates are streamed as changes. When a stream is first opened with `\"changes=true\"`, streaming positions will return the full snapshot first for all positions, and then any changes after that. When `\"changes=true\"`, the PositionID field is returned with each change, along with the fields that changed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Positions  # noqa: E501

        Stream positions for the given accounts. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_positions_with_http_info(account_ids, changes, async_req=True)
        >>> result = thread.get()

        :param account_ids: List of valid Account IDs for the authenticated user in comma separated format; for example `\"61999124,68910124\"`. 1 to 25 Account IDs can be specified, comma separated. (required)
        :type account_ids: str
        :param changes: A boolean value that specifies whether or not position updates are streamed as changes. When a stream is first opened with `\"changes=true\"`, streaming positions will return the full snapshot first for all positions, and then any changes after that. When `\"changes=true\"`, the PositionID field is returned with each change, along with the fields that changed.
        :type changes: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamPositions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account_ids',
            'changes'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_positions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_ids']:
            _path_params['accountIds'] = _params['account_ids']


        # process the query parameters
        _query_params = []
        if _params.get('changes') is not None:  # noqa: E501
            _query_params.append(('changes', _params['changes']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v3+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "StreamPositions200Response",
            '400': "ErrorResponse1",
            '401': "ErrorResponse1",
            '403': "ErrorResponse1",
            '404': "ErrorResponse1",
            '429': "ErrorResponse1",
            '503': "ErrorResponse1",
            '504': "ErrorResponse1",
        }

        return self.api_client.call_api(
            '/v3/brokerage/stream/accounts/{accountIds}/positions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stream_wallets(self, account : Annotated[StrictStr, Field(..., description="A valid crypto Account ID for the authenticated user; for example `\"61999124C\"`.")], **kwargs) -> StreamWallets200Response:  # noqa: E501
        """Stream Wallets  # noqa: E501

        Streams wallet information. Request valid for `Crypto` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_wallets(account, async_req=True)
        >>> result = thread.get()

        :param account: A valid crypto Account ID for the authenticated user; for example `\"61999124C\"`. (required)
        :type account: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamWallets200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_wallets_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_wallets_with_http_info(account, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_wallets_with_http_info(self, account : Annotated[StrictStr, Field(..., description="A valid crypto Account ID for the authenticated user; for example `\"61999124C\"`.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Wallets  # noqa: E501

        Streams wallet information. Request valid for `Crypto` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_wallets_with_http_info(account, async_req=True)
        >>> result = thread.get()

        :param account: A valid crypto Account ID for the authenticated user; for example `\"61999124C\"`. (required)
        :type account: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamWallets200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_wallets" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account']:
            _path_params['account'] = _params['account']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v2+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "StreamWallets200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/brokerage/stream/accounts/{account}/wallets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
