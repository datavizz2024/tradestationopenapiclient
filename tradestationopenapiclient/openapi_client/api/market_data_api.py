# coding: utf-8

"""
    

    # Authentication For more information on authorization and gaining an access/refresh token, please visit: [Authentication](/docs/fundamentals/authentication/auth-overview). <SecurityDefinitions /> 

    The version of the OpenAPI document: 
    Contact: ClientServices@tradestation.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr

from typing import Optional, Union

from openapi_client.models.bars import Bars
from openapi_client.models.expirations import Expirations
from openapi_client.models.get_quote_change_stream200_response import GetQuoteChangeStream200Response
from openapi_client.models.quote_snapshot import QuoteSnapshot
from openapi_client.models.risk_reward_analysis_input import RiskRewardAnalysisInput
from openapi_client.models.risk_reward_analysis_result import RiskRewardAnalysisResult
from openapi_client.models.spread import Spread
from openapi_client.models.spread_types import SpreadTypes
from openapi_client.models.stream_bars200_response import StreamBars200Response
from openapi_client.models.stream_market_depth_aggregates200_response import StreamMarketDepthAggregates200Response
from openapi_client.models.stream_market_depth_quotes200_response import StreamMarketDepthQuotes200Response
from openapi_client.models.strikes import Strikes
from openapi_client.models.symbol_details_response import SymbolDetailsResponse
from openapi_client.models.symbol_names import SymbolNames

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class MarketDataApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def get_bars(self, symbol : Annotated[StrictStr, Field(..., description="The valid symbol string.")], interval : Annotated[Optional[StrictStr], Field(description="Default: `1`.  Interval that each bar will consist of -  for minute bars, the number of minutes aggregated in a single bar.  For crypto symbols, valid values are: `1`, `5`, `15`, `30`, `60`, `240`, `480`.  For bar units other than minute, value must be `1`.  For unit `Minute` the max allowed `Interval` is 1440.")] = None, unit : Annotated[Optional[StrictStr], Field(description="Default: `Daily`. The unit of time for each bar interval. Valid values are: `Minute, Daily, Weekly, Monthly`.")] = None, barsback : Annotated[Optional[StrictStr], Field(description="Default: `1`.  Number of bars back to fetch (or retrieve). The maximum number of intraday bars back that a user can query is 57,600. There is no limit on daily, weekly, or monthly bars. This parameter is mutually exclusive with `firstdate`")] = None, firstdate : Annotated[Optional[StrictStr], Field(description="Does not have a default value. The first date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `barsback`.")] = None, lastdate : Annotated[Optional[StrictStr], Field(description="Defaults to current timestamp. The last date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `startdate` and should be used instead of that parameter, since `startdate` is now deprecated.")] = None, sessiontemplate : Annotated[Optional[StrictStr], Field(description="United States (US) stock market session templates, that extend bars returned to include  those outside of the regular trading session. Ignored for non-US equity symbols. Valid values are: `USEQPre`, `USEQPost`, `USEQPreAndPost`, `Default`.")] = None, startdate : Annotated[Optional[StrictStr], Field(description="Defaults to current timestamp. The last date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `lastdate`. This parameter is deprecated; use `lastdate` instead of `startdate`.")] = None, **kwargs) -> Bars:  # noqa: E501
        """Get Bars  # noqa: E501

        Fetches marketdata bars for the given symbol, interval, and timeframe. The maximum amount of intraday bars a user can fetch is 57,600 per request. This is calculated either by the amount of barsback or bars within a timeframe requested.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bars(symbol, interval, unit, barsback, firstdate, lastdate, sessiontemplate, startdate, async_req=True)
        >>> result = thread.get()

        :param symbol: The valid symbol string. (required)
        :type symbol: str
        :param interval: Default: `1`.  Interval that each bar will consist of -  for minute bars, the number of minutes aggregated in a single bar.  For crypto symbols, valid values are: `1`, `5`, `15`, `30`, `60`, `240`, `480`.  For bar units other than minute, value must be `1`.  For unit `Minute` the max allowed `Interval` is 1440.
        :type interval: str
        :param unit: Default: `Daily`. The unit of time for each bar interval. Valid values are: `Minute, Daily, Weekly, Monthly`.
        :type unit: str
        :param barsback: Default: `1`.  Number of bars back to fetch (or retrieve). The maximum number of intraday bars back that a user can query is 57,600. There is no limit on daily, weekly, or monthly bars. This parameter is mutually exclusive with `firstdate`
        :type barsback: str
        :param firstdate: Does not have a default value. The first date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `barsback`.
        :type firstdate: str
        :param lastdate: Defaults to current timestamp. The last date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `startdate` and should be used instead of that parameter, since `startdate` is now deprecated.
        :type lastdate: str
        :param sessiontemplate: United States (US) stock market session templates, that extend bars returned to include  those outside of the regular trading session. Ignored for non-US equity symbols. Valid values are: `USEQPre`, `USEQPost`, `USEQPreAndPost`, `Default`.
        :type sessiontemplate: str
        :param startdate: Defaults to current timestamp. The last date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `lastdate`. This parameter is deprecated; use `lastdate` instead of `startdate`.
        :type startdate: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Bars
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bars_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bars_with_http_info(symbol, interval, unit, barsback, firstdate, lastdate, sessiontemplate, startdate, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bars_with_http_info(self, symbol : Annotated[StrictStr, Field(..., description="The valid symbol string.")], interval : Annotated[Optional[StrictStr], Field(description="Default: `1`.  Interval that each bar will consist of -  for minute bars, the number of minutes aggregated in a single bar.  For crypto symbols, valid values are: `1`, `5`, `15`, `30`, `60`, `240`, `480`.  For bar units other than minute, value must be `1`.  For unit `Minute` the max allowed `Interval` is 1440.")] = None, unit : Annotated[Optional[StrictStr], Field(description="Default: `Daily`. The unit of time for each bar interval. Valid values are: `Minute, Daily, Weekly, Monthly`.")] = None, barsback : Annotated[Optional[StrictStr], Field(description="Default: `1`.  Number of bars back to fetch (or retrieve). The maximum number of intraday bars back that a user can query is 57,600. There is no limit on daily, weekly, or monthly bars. This parameter is mutually exclusive with `firstdate`")] = None, firstdate : Annotated[Optional[StrictStr], Field(description="Does not have a default value. The first date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `barsback`.")] = None, lastdate : Annotated[Optional[StrictStr], Field(description="Defaults to current timestamp. The last date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `startdate` and should be used instead of that parameter, since `startdate` is now deprecated.")] = None, sessiontemplate : Annotated[Optional[StrictStr], Field(description="United States (US) stock market session templates, that extend bars returned to include  those outside of the regular trading session. Ignored for non-US equity symbols. Valid values are: `USEQPre`, `USEQPost`, `USEQPreAndPost`, `Default`.")] = None, startdate : Annotated[Optional[StrictStr], Field(description="Defaults to current timestamp. The last date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `lastdate`. This parameter is deprecated; use `lastdate` instead of `startdate`.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Bars  # noqa: E501

        Fetches marketdata bars for the given symbol, interval, and timeframe. The maximum amount of intraday bars a user can fetch is 57,600 per request. This is calculated either by the amount of barsback or bars within a timeframe requested.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bars_with_http_info(symbol, interval, unit, barsback, firstdate, lastdate, sessiontemplate, startdate, async_req=True)
        >>> result = thread.get()

        :param symbol: The valid symbol string. (required)
        :type symbol: str
        :param interval: Default: `1`.  Interval that each bar will consist of -  for minute bars, the number of minutes aggregated in a single bar.  For crypto symbols, valid values are: `1`, `5`, `15`, `30`, `60`, `240`, `480`.  For bar units other than minute, value must be `1`.  For unit `Minute` the max allowed `Interval` is 1440.
        :type interval: str
        :param unit: Default: `Daily`. The unit of time for each bar interval. Valid values are: `Minute, Daily, Weekly, Monthly`.
        :type unit: str
        :param barsback: Default: `1`.  Number of bars back to fetch (or retrieve). The maximum number of intraday bars back that a user can query is 57,600. There is no limit on daily, weekly, or monthly bars. This parameter is mutually exclusive with `firstdate`
        :type barsback: str
        :param firstdate: Does not have a default value. The first date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `barsback`.
        :type firstdate: str
        :param lastdate: Defaults to current timestamp. The last date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `startdate` and should be used instead of that parameter, since `startdate` is now deprecated.
        :type lastdate: str
        :param sessiontemplate: United States (US) stock market session templates, that extend bars returned to include  those outside of the regular trading session. Ignored for non-US equity symbols. Valid values are: `USEQPre`, `USEQPost`, `USEQPreAndPost`, `Default`.
        :type sessiontemplate: str
        :param startdate: Defaults to current timestamp. The last date formatted as `YYYY-MM-DD`,`2020-04-20T18:00:00Z`. This parameter is mutually exclusive with `lastdate`. This parameter is deprecated; use `lastdate` instead of `startdate`.
        :type startdate: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Bars, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'symbol',
            'interval',
            'unit',
            'barsback',
            'firstdate',
            'lastdate',
            'sessiontemplate',
            'startdate'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bars" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['symbol']:
            _path_params['symbol'] = _params['symbol']


        # process the query parameters
        _query_params = []
        if _params.get('interval') is not None:  # noqa: E501
            _query_params.append(('interval', _params['interval']))

        if _params.get('unit') is not None:  # noqa: E501
            _query_params.append(('unit', _params['unit']))

        if _params.get('barsback') is not None:  # noqa: E501
            _query_params.append(('barsback', _params['barsback']))

        if _params.get('firstdate') is not None:  # noqa: E501
            _query_params.append(('firstdate', _params['firstdate']))

        if _params.get('lastdate') is not None:  # noqa: E501
            _query_params.append(('lastdate', _params['lastdate']))

        if _params.get('sessiontemplate') is not None:  # noqa: E501
            _query_params.append(('sessiontemplate', _params['sessiontemplate']))

        if _params.get('startdate') is not None:  # noqa: E501
            _query_params.append(('startdate', _params['startdate']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Bars",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/barcharts/{symbol}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_crypto_symbol_names(self, **kwargs) -> SymbolNames:  # noqa: E501
        """Get Crypto Symbol Names  # noqa: E501

        Fetches all crypto Symbol Names information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_crypto_symbol_names(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SymbolNames
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_crypto_symbol_names_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_crypto_symbol_names_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def get_crypto_symbol_names_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Crypto Symbol Names  # noqa: E501

        Fetches all crypto Symbol Names information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_crypto_symbol_names_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SymbolNames, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crypto_symbol_names" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "SymbolNames",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/symbollists/cryptopairs/symbolnames', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_option_chain(self, underlying : Annotated[StrictStr, Field(..., description="The symbol for the underlying security on which the option contracts are based.")], expiration : Annotated[Optional[datetime], Field(description="Date on which the option contract expires; must be a valid expiration date. Defaults to the next contract expiration date.")] = None, expiration2 : Annotated[Optional[datetime], Field(description="Second contract expiration date required for Calendar and Diagonal spreads.")] = None, strike_proximity : Annotated[Optional[StrictInt], Field(description="Specifies the number of spreads to display above and below the priceCenter.")] = None, spread_type : Annotated[Optional[StrictStr], Field(description="Specifies the name of the spread type to use.")] = None, risk_free_rate : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The theoretical rate of return of an investment with zero risk. Defaults to the current quote for $IRX.X. The percentage rate should be specified as a decimal value. For example, to use 2% for the rate, pass in 0.02.")] = None, price_center : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Specifies the strike price center. Defaults to the last quoted price for the underlying security.")] = None, strike_interval : Annotated[Optional[StrictInt], Field(description="Specifies the desired interval between the strike prices in a spread. It must be greater than or equal to 1. A value of 1 uses consecutive strikes; a value of 2 skips one between strikes; and so on.")] = None, enable_greeks : Annotated[Optional[StrictBool], Field(description="Specifies whether or not greeks properties are returned.")] = None, strike_range : Annotated[Optional[StrictStr], Field(description="* If the filter is `ITM` (in-the-money), the chain includes only spreads that have an intrinsic value greater than zero. * If the filter is `OTM` (out-of-the-money), the chain includes only spreads that have an intrinsic value equal to zero.")] = None, option_type : Annotated[Optional[StrictStr], Field(description="Filters the spreads by a specific option type. Valid values are `All`, `Call`, and `Put`.")] = None, **kwargs) -> Spread:  # noqa: E501
        """Stream Option Chain  # noqa: E501

        Stream a chain of option spreads for a given underlying symbol, spread type, and expiration. A maximum of 10 concurrent streams is allowed.  For options calculations, the WebAPI uses the following: * 90 days for historical volatility of the underlying * Bjerksund and Stensland option pricing model * Ask price for price of the option   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_chain(underlying, expiration, expiration2, strike_proximity, spread_type, risk_free_rate, price_center, strike_interval, enable_greeks, strike_range, option_type, async_req=True)
        >>> result = thread.get()

        :param underlying: The symbol for the underlying security on which the option contracts are based. (required)
        :type underlying: str
        :param expiration: Date on which the option contract expires; must be a valid expiration date. Defaults to the next contract expiration date.
        :type expiration: datetime
        :param expiration2: Second contract expiration date required for Calendar and Diagonal spreads.
        :type expiration2: datetime
        :param strike_proximity: Specifies the number of spreads to display above and below the priceCenter.
        :type strike_proximity: int
        :param spread_type: Specifies the name of the spread type to use.
        :type spread_type: str
        :param risk_free_rate: The theoretical rate of return of an investment with zero risk. Defaults to the current quote for $IRX.X. The percentage rate should be specified as a decimal value. For example, to use 2% for the rate, pass in 0.02.
        :type risk_free_rate: float
        :param price_center: Specifies the strike price center. Defaults to the last quoted price for the underlying security.
        :type price_center: float
        :param strike_interval: Specifies the desired interval between the strike prices in a spread. It must be greater than or equal to 1. A value of 1 uses consecutive strikes; a value of 2 skips one between strikes; and so on.
        :type strike_interval: int
        :param enable_greeks: Specifies whether or not greeks properties are returned.
        :type enable_greeks: bool
        :param strike_range: * If the filter is `ITM` (in-the-money), the chain includes only spreads that have an intrinsic value greater than zero. * If the filter is `OTM` (out-of-the-money), the chain includes only spreads that have an intrinsic value equal to zero.
        :type strike_range: str
        :param option_type: Filters the spreads by a specific option type. Valid values are `All`, `Call`, and `Put`.
        :type option_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Spread
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_option_chain_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_option_chain_with_http_info(underlying, expiration, expiration2, strike_proximity, spread_type, risk_free_rate, price_center, strike_interval, enable_greeks, strike_range, option_type, **kwargs)  # noqa: E501

    @validate_arguments
    def get_option_chain_with_http_info(self, underlying : Annotated[StrictStr, Field(..., description="The symbol for the underlying security on which the option contracts are based.")], expiration : Annotated[Optional[datetime], Field(description="Date on which the option contract expires; must be a valid expiration date. Defaults to the next contract expiration date.")] = None, expiration2 : Annotated[Optional[datetime], Field(description="Second contract expiration date required for Calendar and Diagonal spreads.")] = None, strike_proximity : Annotated[Optional[StrictInt], Field(description="Specifies the number of spreads to display above and below the priceCenter.")] = None, spread_type : Annotated[Optional[StrictStr], Field(description="Specifies the name of the spread type to use.")] = None, risk_free_rate : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The theoretical rate of return of an investment with zero risk. Defaults to the current quote for $IRX.X. The percentage rate should be specified as a decimal value. For example, to use 2% for the rate, pass in 0.02.")] = None, price_center : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Specifies the strike price center. Defaults to the last quoted price for the underlying security.")] = None, strike_interval : Annotated[Optional[StrictInt], Field(description="Specifies the desired interval between the strike prices in a spread. It must be greater than or equal to 1. A value of 1 uses consecutive strikes; a value of 2 skips one between strikes; and so on.")] = None, enable_greeks : Annotated[Optional[StrictBool], Field(description="Specifies whether or not greeks properties are returned.")] = None, strike_range : Annotated[Optional[StrictStr], Field(description="* If the filter is `ITM` (in-the-money), the chain includes only spreads that have an intrinsic value greater than zero. * If the filter is `OTM` (out-of-the-money), the chain includes only spreads that have an intrinsic value equal to zero.")] = None, option_type : Annotated[Optional[StrictStr], Field(description="Filters the spreads by a specific option type. Valid values are `All`, `Call`, and `Put`.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Option Chain  # noqa: E501

        Stream a chain of option spreads for a given underlying symbol, spread type, and expiration. A maximum of 10 concurrent streams is allowed.  For options calculations, the WebAPI uses the following: * 90 days for historical volatility of the underlying * Bjerksund and Stensland option pricing model * Ask price for price of the option   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_chain_with_http_info(underlying, expiration, expiration2, strike_proximity, spread_type, risk_free_rate, price_center, strike_interval, enable_greeks, strike_range, option_type, async_req=True)
        >>> result = thread.get()

        :param underlying: The symbol for the underlying security on which the option contracts are based. (required)
        :type underlying: str
        :param expiration: Date on which the option contract expires; must be a valid expiration date. Defaults to the next contract expiration date.
        :type expiration: datetime
        :param expiration2: Second contract expiration date required for Calendar and Diagonal spreads.
        :type expiration2: datetime
        :param strike_proximity: Specifies the number of spreads to display above and below the priceCenter.
        :type strike_proximity: int
        :param spread_type: Specifies the name of the spread type to use.
        :type spread_type: str
        :param risk_free_rate: The theoretical rate of return of an investment with zero risk. Defaults to the current quote for $IRX.X. The percentage rate should be specified as a decimal value. For example, to use 2% for the rate, pass in 0.02.
        :type risk_free_rate: float
        :param price_center: Specifies the strike price center. Defaults to the last quoted price for the underlying security.
        :type price_center: float
        :param strike_interval: Specifies the desired interval between the strike prices in a spread. It must be greater than or equal to 1. A value of 1 uses consecutive strikes; a value of 2 skips one between strikes; and so on.
        :type strike_interval: int
        :param enable_greeks: Specifies whether or not greeks properties are returned.
        :type enable_greeks: bool
        :param strike_range: * If the filter is `ITM` (in-the-money), the chain includes only spreads that have an intrinsic value greater than zero. * If the filter is `OTM` (out-of-the-money), the chain includes only spreads that have an intrinsic value equal to zero.
        :type strike_range: str
        :param option_type: Filters the spreads by a specific option type. Valid values are `All`, `Call`, and `Put`.
        :type option_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Spread, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'underlying',
            'expiration',
            'expiration2',
            'strike_proximity',
            'spread_type',
            'risk_free_rate',
            'price_center',
            'strike_interval',
            'enable_greeks',
            'strike_range',
            'option_type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_option_chain" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['underlying']:
            _path_params['underlying'] = _params['underlying']


        # process the query parameters
        _query_params = []
        if _params.get('expiration') is not None:  # noqa: E501
            if isinstance(_params['expiration'], datetime):
                _query_params.append(('expiration', _params['expiration'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('expiration', _params['expiration']))

        if _params.get('expiration2') is not None:  # noqa: E501
            if isinstance(_params['expiration2'], datetime):
                _query_params.append(('expiration2', _params['expiration2'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('expiration2', _params['expiration2']))

        if _params.get('strike_proximity') is not None:  # noqa: E501
            _query_params.append(('strikeProximity', _params['strike_proximity']))

        if _params.get('spread_type') is not None:  # noqa: E501
            _query_params.append(('spreadType', _params['spread_type']))

        if _params.get('risk_free_rate') is not None:  # noqa: E501
            _query_params.append(('riskFreeRate', _params['risk_free_rate']))

        if _params.get('price_center') is not None:  # noqa: E501
            _query_params.append(('priceCenter', _params['price_center']))

        if _params.get('strike_interval') is not None:  # noqa: E501
            _query_params.append(('strikeInterval', _params['strike_interval']))

        if _params.get('enable_greeks') is not None:  # noqa: E501
            _query_params.append(('enableGreeks', _params['enable_greeks']))

        if _params.get('strike_range') is not None:  # noqa: E501
            _query_params.append(('strikeRange', _params['strike_range']))

        if _params.get('option_type') is not None:  # noqa: E501
            _query_params.append(('optionType', _params['option_type']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v2+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Spread",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/stream/options/chains/{underlying}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_option_expirations(self, underlying : Annotated[StrictStr, Field(..., description="The symbol for the underlying security on which the option contracts are based. The underlying symbol must be an equity or index.")], strike_price : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Strike price. If provided, only expirations for that strike price will be returned.")] = None, **kwargs) -> Expirations:  # noqa: E501
        """Get Option Expirations  # noqa: E501

        Get the available option contract expiration dates for the underlying symbol.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_expirations(underlying, strike_price, async_req=True)
        >>> result = thread.get()

        :param underlying: The symbol for the underlying security on which the option contracts are based. The underlying symbol must be an equity or index. (required)
        :type underlying: str
        :param strike_price: Strike price. If provided, only expirations for that strike price will be returned.
        :type strike_price: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Expirations
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_option_expirations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_option_expirations_with_http_info(underlying, strike_price, **kwargs)  # noqa: E501

    @validate_arguments
    def get_option_expirations_with_http_info(self, underlying : Annotated[StrictStr, Field(..., description="The symbol for the underlying security on which the option contracts are based. The underlying symbol must be an equity or index.")], strike_price : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Strike price. If provided, only expirations for that strike price will be returned.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Option Expirations  # noqa: E501

        Get the available option contract expiration dates for the underlying symbol.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_expirations_with_http_info(underlying, strike_price, async_req=True)
        >>> result = thread.get()

        :param underlying: The symbol for the underlying security on which the option contracts are based. The underlying symbol must be an equity or index. (required)
        :type underlying: str
        :param strike_price: Strike price. If provided, only expirations for that strike price will be returned.
        :type strike_price: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Expirations, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'underlying',
            'strike_price'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_option_expirations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['underlying']:
            _path_params['underlying'] = _params['underlying']


        # process the query parameters
        _query_params = []
        if _params.get('strike_price') is not None:  # noqa: E501
            _query_params.append(('strikePrice', _params['strike_price']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Expirations",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/options/expirations/{underlying}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_option_quotes(self, legs_0_symbol : Annotated[StrictStr, Field(..., description="* `legs`: Individual components of a multi-part trade. * `[0]`: Represents the position in the legs array. * `Symbol`: Option contract symbol or underlying symbol to be traded for this leg. In some cases, the space in an option symbol may need to be explicitly URI encoded as %20, such as `MSFT%20220916C305`.")], legs_0_ratio : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="* `legs`: Individual components of a multi-part trade. * `[0]`: Represents the position in the legs array. * `Ratio`: The number of option contracts or underlying shares for this leg, relative to the other legs. Use a positive number to represent a buy trade and a negative number to represent a sell trade. For example, a quote for a Butterfly spread can be requested using ratios of 1, -2, and 1: buy 1 contract of the first leg, sell 2 contracts of the second leg, and buy 1 contract of the third leg.")] = None, risk_free_rate : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The theoretical rate of return of an investment with zero risk. Defaults to the current quote for $IRX.X. The percentage rate should be specified as a decimal value. For example, to use 2% for the rate, pass in 0.02.")] = None, enable_greeks : Annotated[Optional[StrictBool], Field(description="Specifies whether or not greeks properties are returned.")] = None, **kwargs) -> Spread:  # noqa: E501
        """Stream Option Quotes  # noqa: E501

        Stream price quotes and greeks for the specified option spread. A maximum of 10 concurrent streams is allowed. Leg indexes are expected to be sequential starting at zero. For example, if there are three legs, the legs in the request should contain Legs[0], Legs[1], and Legs[2]. Note that there is no required order for the Legs in the query parameters.  For example, if there are 2 legs, Legs[0].Symbol, Legs[0].Ratio, Legs[1].Symbol, and Legs[1].Ratio can be in any order in the query parameters.  For options calculations, the WebAPI uses the following: * 90 days for historical volatility of the underlying * Bjerksund and Stensland option pricing model * Ask price for price of the option   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_quotes(legs_0_symbol, legs_0_ratio, risk_free_rate, enable_greeks, async_req=True)
        >>> result = thread.get()

        :param legs_0_symbol: * `legs`: Individual components of a multi-part trade. * `[0]`: Represents the position in the legs array. * `Symbol`: Option contract symbol or underlying symbol to be traded for this leg. In some cases, the space in an option symbol may need to be explicitly URI encoded as %20, such as `MSFT%20220916C305`. (required)
        :type legs_0_symbol: str
        :param legs_0_ratio: * `legs`: Individual components of a multi-part trade. * `[0]`: Represents the position in the legs array. * `Ratio`: The number of option contracts or underlying shares for this leg, relative to the other legs. Use a positive number to represent a buy trade and a negative number to represent a sell trade. For example, a quote for a Butterfly spread can be requested using ratios of 1, -2, and 1: buy 1 contract of the first leg, sell 2 contracts of the second leg, and buy 1 contract of the third leg.
        :type legs_0_ratio: float
        :param risk_free_rate: The theoretical rate of return of an investment with zero risk. Defaults to the current quote for $IRX.X. The percentage rate should be specified as a decimal value. For example, to use 2% for the rate, pass in 0.02.
        :type risk_free_rate: float
        :param enable_greeks: Specifies whether or not greeks properties are returned.
        :type enable_greeks: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Spread
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_option_quotes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_option_quotes_with_http_info(legs_0_symbol, legs_0_ratio, risk_free_rate, enable_greeks, **kwargs)  # noqa: E501

    @validate_arguments
    def get_option_quotes_with_http_info(self, legs_0_symbol : Annotated[StrictStr, Field(..., description="* `legs`: Individual components of a multi-part trade. * `[0]`: Represents the position in the legs array. * `Symbol`: Option contract symbol or underlying symbol to be traded for this leg. In some cases, the space in an option symbol may need to be explicitly URI encoded as %20, such as `MSFT%20220916C305`.")], legs_0_ratio : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="* `legs`: Individual components of a multi-part trade. * `[0]`: Represents the position in the legs array. * `Ratio`: The number of option contracts or underlying shares for this leg, relative to the other legs. Use a positive number to represent a buy trade and a negative number to represent a sell trade. For example, a quote for a Butterfly spread can be requested using ratios of 1, -2, and 1: buy 1 contract of the first leg, sell 2 contracts of the second leg, and buy 1 contract of the third leg.")] = None, risk_free_rate : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The theoretical rate of return of an investment with zero risk. Defaults to the current quote for $IRX.X. The percentage rate should be specified as a decimal value. For example, to use 2% for the rate, pass in 0.02.")] = None, enable_greeks : Annotated[Optional[StrictBool], Field(description="Specifies whether or not greeks properties are returned.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Option Quotes  # noqa: E501

        Stream price quotes and greeks for the specified option spread. A maximum of 10 concurrent streams is allowed. Leg indexes are expected to be sequential starting at zero. For example, if there are three legs, the legs in the request should contain Legs[0], Legs[1], and Legs[2]. Note that there is no required order for the Legs in the query parameters.  For example, if there are 2 legs, Legs[0].Symbol, Legs[0].Ratio, Legs[1].Symbol, and Legs[1].Ratio can be in any order in the query parameters.  For options calculations, the WebAPI uses the following: * 90 days for historical volatility of the underlying * Bjerksund and Stensland option pricing model * Ask price for price of the option   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_quotes_with_http_info(legs_0_symbol, legs_0_ratio, risk_free_rate, enable_greeks, async_req=True)
        >>> result = thread.get()

        :param legs_0_symbol: * `legs`: Individual components of a multi-part trade. * `[0]`: Represents the position in the legs array. * `Symbol`: Option contract symbol or underlying symbol to be traded for this leg. In some cases, the space in an option symbol may need to be explicitly URI encoded as %20, such as `MSFT%20220916C305`. (required)
        :type legs_0_symbol: str
        :param legs_0_ratio: * `legs`: Individual components of a multi-part trade. * `[0]`: Represents the position in the legs array. * `Ratio`: The number of option contracts or underlying shares for this leg, relative to the other legs. Use a positive number to represent a buy trade and a negative number to represent a sell trade. For example, a quote for a Butterfly spread can be requested using ratios of 1, -2, and 1: buy 1 contract of the first leg, sell 2 contracts of the second leg, and buy 1 contract of the third leg.
        :type legs_0_ratio: float
        :param risk_free_rate: The theoretical rate of return of an investment with zero risk. Defaults to the current quote for $IRX.X. The percentage rate should be specified as a decimal value. For example, to use 2% for the rate, pass in 0.02.
        :type risk_free_rate: float
        :param enable_greeks: Specifies whether or not greeks properties are returned.
        :type enable_greeks: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Spread, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'legs_0_symbol',
            'legs_0_ratio',
            'risk_free_rate',
            'enable_greeks'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_option_quotes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('legs_0_symbol') is not None:  # noqa: E501
            _query_params.append(('legs[0].Symbol', _params['legs_0_symbol']))

        if _params.get('legs_0_ratio') is not None:  # noqa: E501
            _query_params.append(('legs[0].Ratio', _params['legs_0_ratio']))

        if _params.get('risk_free_rate') is not None:  # noqa: E501
            _query_params.append(('riskFreeRate', _params['risk_free_rate']))

        if _params.get('enable_greeks') is not None:  # noqa: E501
            _query_params.append(('enableGreeks', _params['enable_greeks']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v2+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Spread",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/stream/options/quotes', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_option_risk_reward(self, risk_reward_analysis_input : Optional[RiskRewardAnalysisInput] = None, **kwargs) -> RiskRewardAnalysisResult:  # noqa: E501
        """Get Option Risk Reward  # noqa: E501

        Analyze the risk vs. reward of a potential option trade. This endpoint is not applicable for option spread types with different expirations, such as Calendar and Diagonal.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_risk_reward(risk_reward_analysis_input, async_req=True)
        >>> result = thread.get()

        :param risk_reward_analysis_input:
        :type risk_reward_analysis_input: RiskRewardAnalysisInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RiskRewardAnalysisResult
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_option_risk_reward_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_option_risk_reward_with_http_info(risk_reward_analysis_input, **kwargs)  # noqa: E501

    @validate_arguments
    def get_option_risk_reward_with_http_info(self, risk_reward_analysis_input : Optional[RiskRewardAnalysisInput] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Option Risk Reward  # noqa: E501

        Analyze the risk vs. reward of a potential option trade. This endpoint is not applicable for option spread types with different expirations, such as Calendar and Diagonal.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_risk_reward_with_http_info(risk_reward_analysis_input, async_req=True)
        >>> result = thread.get()

        :param risk_reward_analysis_input:
        :type risk_reward_analysis_input: RiskRewardAnalysisInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RiskRewardAnalysisResult, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'risk_reward_analysis_input'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_option_risk_reward" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['risk_reward_analysis_input'] is not None:
            _body_params = _params['risk_reward_analysis_input']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "RiskRewardAnalysisResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/options/riskreward', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_option_spread_types(self, **kwargs) -> SpreadTypes:  # noqa: E501
        """Get Option Spread Types  # noqa: E501

        Get the available spread types for option chains.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_spread_types(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SpreadTypes
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_option_spread_types_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_option_spread_types_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def get_option_spread_types_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Option Spread Types  # noqa: E501

        Get the available spread types for option chains.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_spread_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SpreadTypes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_option_spread_types" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "SpreadTypes",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/options/spreadtypes', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_option_strikes(self, underlying : Annotated[StrictStr, Field(..., description="The symbol for the underlying security on which the option contracts are based. The underlying symbol must be an equity or index.")], spread_type : Annotated[Optional[StrictStr], Field(description="The name of the spread type to get the strikes for. This value can be obtained from the [Get Option Spread Types](#operation/GetOptionSpreadTypes) endpoint.")] = None, strike_interval : Annotated[Optional[StrictInt], Field(description="Specifies the desired interval between the strike prices in a spread. It must be greater than or equal to 1. A value of 1 uses consecutive strikes; a value of 2 skips one between strikes; and so on.")] = None, expiration : Annotated[Optional[datetime], Field(description="Date on which the option contract expires; must be a valid expiration date. Defaults to the next contract expiration date.")] = None, expiration2 : Annotated[Optional[datetime], Field(description="Second contract expiration date required for Calendar and Diagonal spreads.")] = None, **kwargs) -> Strikes:  # noqa: E501
        """Get Option Strikes  # noqa: E501

        Get the available strike prices for a spread type and expiration date.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_strikes(underlying, spread_type, strike_interval, expiration, expiration2, async_req=True)
        >>> result = thread.get()

        :param underlying: The symbol for the underlying security on which the option contracts are based. The underlying symbol must be an equity or index. (required)
        :type underlying: str
        :param spread_type: The name of the spread type to get the strikes for. This value can be obtained from the [Get Option Spread Types](#operation/GetOptionSpreadTypes) endpoint.
        :type spread_type: str
        :param strike_interval: Specifies the desired interval between the strike prices in a spread. It must be greater than or equal to 1. A value of 1 uses consecutive strikes; a value of 2 skips one between strikes; and so on.
        :type strike_interval: int
        :param expiration: Date on which the option contract expires; must be a valid expiration date. Defaults to the next contract expiration date.
        :type expiration: datetime
        :param expiration2: Second contract expiration date required for Calendar and Diagonal spreads.
        :type expiration2: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Strikes
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_option_strikes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_option_strikes_with_http_info(underlying, spread_type, strike_interval, expiration, expiration2, **kwargs)  # noqa: E501

    @validate_arguments
    def get_option_strikes_with_http_info(self, underlying : Annotated[StrictStr, Field(..., description="The symbol for the underlying security on which the option contracts are based. The underlying symbol must be an equity or index.")], spread_type : Annotated[Optional[StrictStr], Field(description="The name of the spread type to get the strikes for. This value can be obtained from the [Get Option Spread Types](#operation/GetOptionSpreadTypes) endpoint.")] = None, strike_interval : Annotated[Optional[StrictInt], Field(description="Specifies the desired interval between the strike prices in a spread. It must be greater than or equal to 1. A value of 1 uses consecutive strikes; a value of 2 skips one between strikes; and so on.")] = None, expiration : Annotated[Optional[datetime], Field(description="Date on which the option contract expires; must be a valid expiration date. Defaults to the next contract expiration date.")] = None, expiration2 : Annotated[Optional[datetime], Field(description="Second contract expiration date required for Calendar and Diagonal spreads.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Option Strikes  # noqa: E501

        Get the available strike prices for a spread type and expiration date.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_option_strikes_with_http_info(underlying, spread_type, strike_interval, expiration, expiration2, async_req=True)
        >>> result = thread.get()

        :param underlying: The symbol for the underlying security on which the option contracts are based. The underlying symbol must be an equity or index. (required)
        :type underlying: str
        :param spread_type: The name of the spread type to get the strikes for. This value can be obtained from the [Get Option Spread Types](#operation/GetOptionSpreadTypes) endpoint.
        :type spread_type: str
        :param strike_interval: Specifies the desired interval between the strike prices in a spread. It must be greater than or equal to 1. A value of 1 uses consecutive strikes; a value of 2 skips one between strikes; and so on.
        :type strike_interval: int
        :param expiration: Date on which the option contract expires; must be a valid expiration date. Defaults to the next contract expiration date.
        :type expiration: datetime
        :param expiration2: Second contract expiration date required for Calendar and Diagonal spreads.
        :type expiration2: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Strikes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'underlying',
            'spread_type',
            'strike_interval',
            'expiration',
            'expiration2'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_option_strikes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['underlying']:
            _path_params['underlying'] = _params['underlying']


        # process the query parameters
        _query_params = []
        if _params.get('spread_type') is not None:  # noqa: E501
            _query_params.append(('spreadType', _params['spread_type']))

        if _params.get('strike_interval') is not None:  # noqa: E501
            _query_params.append(('strikeInterval', _params['strike_interval']))

        if _params.get('expiration') is not None:  # noqa: E501
            if isinstance(_params['expiration'], datetime):
                _query_params.append(('expiration', _params['expiration'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('expiration', _params['expiration']))

        if _params.get('expiration2') is not None:  # noqa: E501
            if isinstance(_params['expiration2'], datetime):
                _query_params.append(('expiration2', _params['expiration2'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('expiration2', _params['expiration2']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "Strikes",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/options/strikes/{underlying}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_quote_change_stream(self, symbols : Annotated[StrictStr, Field(..., description="List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`. No more than 100 symbols per request.")], **kwargs) -> GetQuoteChangeStream200Response:  # noqa: E501
        """Stream Quotes  # noqa: E501

        Streams Quote changes for one or more symbols.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_quote_change_stream(symbols, async_req=True)
        >>> result = thread.get()

        :param symbols: List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`. No more than 100 symbols per request. (required)
        :type symbols: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetQuoteChangeStream200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_quote_change_stream_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_quote_change_stream_with_http_info(symbols, **kwargs)  # noqa: E501

    @validate_arguments
    def get_quote_change_stream_with_http_info(self, symbols : Annotated[StrictStr, Field(..., description="List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`. No more than 100 symbols per request.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Quotes  # noqa: E501

        Streams Quote changes for one or more symbols.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_quote_change_stream_with_http_info(symbols, async_req=True)
        >>> result = thread.get()

        :param symbols: List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`. No more than 100 symbols per request. (required)
        :type symbols: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetQuoteChangeStream200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'symbols'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quote_change_stream" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['symbols']:
            _path_params['symbols'] = _params['symbols']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v2+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "GetQuoteChangeStream200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/stream/quotes/{symbols}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_quote_snapshots(self, symbols : Annotated[StrictStr, Field(..., description="List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`. No more than 100 symbols per request.")], **kwargs) -> QuoteSnapshot:  # noqa: E501
        """Get Quote Snapshots  # noqa: E501

        Fetches a full snapshot of the latest Quote for the given Symbols. For realtime Quote updates, users should use the Quote Stream endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_quote_snapshots(symbols, async_req=True)
        >>> result = thread.get()

        :param symbols: List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`. No more than 100 symbols per request. (required)
        :type symbols: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: QuoteSnapshot
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_quote_snapshots_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_quote_snapshots_with_http_info(symbols, **kwargs)  # noqa: E501

    @validate_arguments
    def get_quote_snapshots_with_http_info(self, symbols : Annotated[StrictStr, Field(..., description="List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`. No more than 100 symbols per request.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Quote Snapshots  # noqa: E501

        Fetches a full snapshot of the latest Quote for the given Symbols. For realtime Quote updates, users should use the Quote Stream endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_quote_snapshots_with_http_info(symbols, async_req=True)
        >>> result = thread.get()

        :param symbols: List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`. No more than 100 symbols per request. (required)
        :type symbols: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(QuoteSnapshot, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'symbols'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_quote_snapshots" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['symbols']:
            _path_params['symbols'] = _params['symbols']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "QuoteSnapshot",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/quotes/{symbols}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_symbol_details(self, symbols : Annotated[StrictStr, Field(..., description="List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`, no more than 50 symbols per request.")], **kwargs) -> SymbolDetailsResponse:  # noqa: E501
        """Get Symbol Details  # noqa: E501

        Fetches symbol details and formatting information for one or more symbols and relevant errors, if any. Use provided formatting objects to display provided prices and quantities from other API endpoints.  * **Decimal** prices should be displayed as decimals. For instance, for a given price of `123.2` the price should be displayed as `123.20`.  * **Fraction** price display formatting should be displayed with the `PriceFormat.Fraction` in the denominator of the fraction part of the given number. For instance, given a price of `534.5` and a `PriceFormat.Fraction` of `8`, the number should be shown as `534 4/8`.  * For **SubFractional** price display formatting, the following equations can be used to derive the display format of `a'b.c` for a given price. For instance, given a price of `125.92969`, a `PriceFormat.Fraction` of `32` and a `PriceFormat.Subfraction` of `4`, the number should be displayed as `125'29.7`. ``` x (Price)                   = 125.92969 y (PriceFormat.Fraction)    = 32 z (PriceFormat.SubFraction) = 4 ``` ``` a = trunc(x) b = trunc(frac(x) * y) c = trunc(((frac(x) - (b/y)) * z * y) / (z/10)) ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_symbol_details(symbols, async_req=True)
        >>> result = thread.get()

        :param symbols: List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`, no more than 50 symbols per request. (required)
        :type symbols: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SymbolDetailsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_symbol_details_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_symbol_details_with_http_info(symbols, **kwargs)  # noqa: E501

    @validate_arguments
    def get_symbol_details_with_http_info(self, symbols : Annotated[StrictStr, Field(..., description="List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`, no more than 50 symbols per request.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Symbol Details  # noqa: E501

        Fetches symbol details and formatting information for one or more symbols and relevant errors, if any. Use provided formatting objects to display provided prices and quantities from other API endpoints.  * **Decimal** prices should be displayed as decimals. For instance, for a given price of `123.2` the price should be displayed as `123.20`.  * **Fraction** price display formatting should be displayed with the `PriceFormat.Fraction` in the denominator of the fraction part of the given number. For instance, given a price of `534.5` and a `PriceFormat.Fraction` of `8`, the number should be shown as `534 4/8`.  * For **SubFractional** price display formatting, the following equations can be used to derive the display format of `a'b.c` for a given price. For instance, given a price of `125.92969`, a `PriceFormat.Fraction` of `32` and a `PriceFormat.Subfraction` of `4`, the number should be displayed as `125'29.7`. ``` x (Price)                   = 125.92969 y (PriceFormat.Fraction)    = 32 z (PriceFormat.SubFraction) = 4 ``` ``` a = trunc(x) b = trunc(frac(x) * y) c = trunc(((frac(x) - (b/y)) * z * y) / (z/10)) ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_symbol_details_with_http_info(symbols, async_req=True)
        >>> result = thread.get()

        :param symbols: List of valid symbols in comma separated format; for example `\"MSFT,BTCUSD\"`, no more than 50 symbols per request. (required)
        :type symbols: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SymbolDetailsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'symbols'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_symbol_details" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['symbols']:
            _path_params['symbols'] = _params['symbols']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "SymbolDetailsResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/symbols/{symbols}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stream_bars(self, symbol : Annotated[StrictStr, Field(..., description="The valid symbol string.")], interval : Annotated[Optional[StrictStr], Field(description="Interval that each bar will consist of -  for minute bars, the number of minutes aggregated in a single bar.  For crypto symbols, valid values are: `1`, `5`, `15`, `30`, `60`, `240`, `480`.  For bar units other than minute, value must be `1`.")] = None, unit : Annotated[Optional[StrictStr], Field(description="Unit of time for each bar interval. Valid values are: `minute`, `daily`, `weekly`, `monthly`, and `second` (crypto only).")] = None, barsback : Annotated[Optional[StrictStr], Field(description="The bars back - for crypto symbols, the max value is 500. for non-crypto the max value is 57600.")] = None, sessiontemplate : Annotated[Optional[StrictStr], Field(description="United States (US) stock market session templates, that extend bars returned to include  those outside of the regular trading session. Ignored for non-US equity symbols. Valid values are: `USEQPre`, `USEQPost`, `USEQPreAndPost`, `Default`.")] = None, **kwargs) -> StreamBars200Response:  # noqa: E501
        """Stream Bars  # noqa: E501

        Streams marketdata bars for the given symbol, interval, and timeframe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_bars(symbol, interval, unit, barsback, sessiontemplate, async_req=True)
        >>> result = thread.get()

        :param symbol: The valid symbol string. (required)
        :type symbol: str
        :param interval: Interval that each bar will consist of -  for minute bars, the number of minutes aggregated in a single bar.  For crypto symbols, valid values are: `1`, `5`, `15`, `30`, `60`, `240`, `480`.  For bar units other than minute, value must be `1`.
        :type interval: str
        :param unit: Unit of time for each bar interval. Valid values are: `minute`, `daily`, `weekly`, `monthly`, and `second` (crypto only).
        :type unit: str
        :param barsback: The bars back - for crypto symbols, the max value is 500. for non-crypto the max value is 57600.
        :type barsback: str
        :param sessiontemplate: United States (US) stock market session templates, that extend bars returned to include  those outside of the regular trading session. Ignored for non-US equity symbols. Valid values are: `USEQPre`, `USEQPost`, `USEQPreAndPost`, `Default`.
        :type sessiontemplate: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamBars200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_bars_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_bars_with_http_info(symbol, interval, unit, barsback, sessiontemplate, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_bars_with_http_info(self, symbol : Annotated[StrictStr, Field(..., description="The valid symbol string.")], interval : Annotated[Optional[StrictStr], Field(description="Interval that each bar will consist of -  for minute bars, the number of minutes aggregated in a single bar.  For crypto symbols, valid values are: `1`, `5`, `15`, `30`, `60`, `240`, `480`.  For bar units other than minute, value must be `1`.")] = None, unit : Annotated[Optional[StrictStr], Field(description="Unit of time for each bar interval. Valid values are: `minute`, `daily`, `weekly`, `monthly`, and `second` (crypto only).")] = None, barsback : Annotated[Optional[StrictStr], Field(description="The bars back - for crypto symbols, the max value is 500. for non-crypto the max value is 57600.")] = None, sessiontemplate : Annotated[Optional[StrictStr], Field(description="United States (US) stock market session templates, that extend bars returned to include  those outside of the regular trading session. Ignored for non-US equity symbols. Valid values are: `USEQPre`, `USEQPost`, `USEQPreAndPost`, `Default`.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Bars  # noqa: E501

        Streams marketdata bars for the given symbol, interval, and timeframe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_bars_with_http_info(symbol, interval, unit, barsback, sessiontemplate, async_req=True)
        >>> result = thread.get()

        :param symbol: The valid symbol string. (required)
        :type symbol: str
        :param interval: Interval that each bar will consist of -  for minute bars, the number of minutes aggregated in a single bar.  For crypto symbols, valid values are: `1`, `5`, `15`, `30`, `60`, `240`, `480`.  For bar units other than minute, value must be `1`.
        :type interval: str
        :param unit: Unit of time for each bar interval. Valid values are: `minute`, `daily`, `weekly`, `monthly`, and `second` (crypto only).
        :type unit: str
        :param barsback: The bars back - for crypto symbols, the max value is 500. for non-crypto the max value is 57600.
        :type barsback: str
        :param sessiontemplate: United States (US) stock market session templates, that extend bars returned to include  those outside of the regular trading session. Ignored for non-US equity symbols. Valid values are: `USEQPre`, `USEQPost`, `USEQPreAndPost`, `Default`.
        :type sessiontemplate: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamBars200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'symbol',
            'interval',
            'unit',
            'barsback',
            'sessiontemplate'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_bars" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['symbol']:
            _path_params['symbol'] = _params['symbol']


        # process the query parameters
        _query_params = []
        if _params.get('interval') is not None:  # noqa: E501
            _query_params.append(('interval', _params['interval']))

        if _params.get('unit') is not None:  # noqa: E501
            _query_params.append(('unit', _params['unit']))

        if _params.get('barsback') is not None:  # noqa: E501
            _query_params.append(('barsback', _params['barsback']))

        if _params.get('sessiontemplate') is not None:  # noqa: E501
            _query_params.append(('sessiontemplate', _params['sessiontemplate']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v2+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "StreamBars200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/stream/barcharts/{symbol}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stream_market_depth_aggregates(self, symbol : Annotated[StrictStr, Field(..., description="A valid symbol for the security.")], maxlevels : Annotated[Optional[StrictInt], Field(description="The maximum number of market depth levels to return. Must be a positive integer. If omitted it defaults to 20.")] = None, **kwargs) -> StreamMarketDepthAggregates200Response:  # noqa: E501
        """Stream Market Depth Aggregates  # noqa: E501

        Stream aggregate market depth quotes for equities, futures and stock options. A separate quote is returned for each price and side, using aggregated data from the participants.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_market_depth_aggregates(symbol, maxlevels, async_req=True)
        >>> result = thread.get()

        :param symbol: A valid symbol for the security. (required)
        :type symbol: str
        :param maxlevels: The maximum number of market depth levels to return. Must be a positive integer. If omitted it defaults to 20.
        :type maxlevels: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamMarketDepthAggregates200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_market_depth_aggregates_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_market_depth_aggregates_with_http_info(symbol, maxlevels, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_market_depth_aggregates_with_http_info(self, symbol : Annotated[StrictStr, Field(..., description="A valid symbol for the security.")], maxlevels : Annotated[Optional[StrictInt], Field(description="The maximum number of market depth levels to return. Must be a positive integer. If omitted it defaults to 20.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Market Depth Aggregates  # noqa: E501

        Stream aggregate market depth quotes for equities, futures and stock options. A separate quote is returned for each price and side, using aggregated data from the participants.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_market_depth_aggregates_with_http_info(symbol, maxlevels, async_req=True)
        >>> result = thread.get()

        :param symbol: A valid symbol for the security. (required)
        :type symbol: str
        :param maxlevels: The maximum number of market depth levels to return. Must be a positive integer. If omitted it defaults to 20.
        :type maxlevels: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamMarketDepthAggregates200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'symbol',
            'maxlevels'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_market_depth_aggregates" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['symbol']:
            _path_params['symbol'] = _params['symbol']


        # process the query parameters
        _query_params = []
        if _params.get('maxlevels') is not None:  # noqa: E501
            _query_params.append(('maxlevels', _params['maxlevels']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v2+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "StreamMarketDepthAggregates200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/stream/marketdepth/aggregates/{symbol}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def stream_market_depth_quotes(self, symbol : Annotated[StrictStr, Field(..., description="A valid symbol for the security.")], maxlevels : Annotated[Optional[StrictInt], Field(description="The maximum number of market depth levels to return. Must be a positive integer. If omitted it defaults to 20.")] = None, **kwargs) -> StreamMarketDepthQuotes200Response:  # noqa: E501
        """Stream Market Depth Quotes  # noqa: E501

        Stream market depth quotes for equities, futures and stock options. A separate quote is returned for each price, side, and participant.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_market_depth_quotes(symbol, maxlevels, async_req=True)
        >>> result = thread.get()

        :param symbol: A valid symbol for the security. (required)
        :type symbol: str
        :param maxlevels: The maximum number of market depth levels to return. Must be a positive integer. If omitted it defaults to 20.
        :type maxlevels: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StreamMarketDepthQuotes200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_market_depth_quotes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_market_depth_quotes_with_http_info(symbol, maxlevels, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_market_depth_quotes_with_http_info(self, symbol : Annotated[StrictStr, Field(..., description="A valid symbol for the security.")], maxlevels : Annotated[Optional[StrictInt], Field(description="The maximum number of market depth levels to return. Must be a positive integer. If omitted it defaults to 20.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stream Market Depth Quotes  # noqa: E501

        Stream market depth quotes for equities, futures and stock options. A separate quote is returned for each price, side, and participant.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stream_market_depth_quotes_with_http_info(symbol, maxlevels, async_req=True)
        >>> result = thread.get()

        :param symbol: A valid symbol for the security. (required)
        :type symbol: str
        :param maxlevels: The maximum number of market depth levels to return. Must be a positive integer. If omitted it defaults to 20.
        :type maxlevels: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StreamMarketDepthQuotes200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'symbol',
            'maxlevels'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_market_depth_quotes" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['symbol']:
            _path_params['symbol'] = _params['symbol']


        # process the query parameters
        _query_params = []
        if _params.get('maxlevels') is not None:  # noqa: E501
            _query_params.append(('maxlevels', _params['maxlevels']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.tradestation.streams.v2+json', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer-Token']  # noqa: E501

        _response_types_map = {
            '200': "StreamMarketDepthQuotes200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '429': "ErrorResponse",
            '503': "ErrorResponse",
            '504': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/v3/marketdata/stream/marketdepth/quotes/{symbol}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
