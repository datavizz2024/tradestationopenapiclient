# coding: utf-8

"""
    

    # Authentication For more information on authorization and gaining an access/refresh token, please visit: [Authentication](/docs/fundamentals/authentication/auth-overview). <SecurityDefinitions /> 

    The version of the OpenAPI document: 
    Contact: ClientServices@tradestation.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import typing
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictStr

from typing import List, Optional

from openapi_client.models.activation_triggers import ActivationTriggers
from openapi_client.models.group_order_request import GroupOrderRequest
from openapi_client.models.order_confirm_responses import OrderConfirmResponses
from openapi_client.models.order_replace_request import OrderReplaceRequest
from openapi_client.models.order_request import OrderRequest
from openapi_client.models.order_response import OrderResponse
from openapi_client.models.order_responses import OrderResponses
from openapi_client.models.routes import Routes

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import ApiTypeError, ApiValueError  # noqa: F401


class OrderExecutionApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def cancel_order(
        self,
        order_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Order ID to cancel. Equity, option or future orderIDs should not include dashes (E.g. `1-2345-6789`). Valid format orderId=`123456789`",
            ),
        ],
        **kwargs
    ) -> OrderResponse:  # noqa: E501
        """Cancel Order  # noqa: E501

        Cancels an active order. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cancel_order(order_id, async_req=True)
        >>> result = thread.get()

        :param order_id: Order ID to cancel. Equity, option or future orderIDs should not include dashes (E.g. `1-2345-6789`). Valid format orderId=`123456789` (required)
        :type order_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrderResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the cancel_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.cancel_order_with_http_info(order_id, **kwargs)  # noqa: E501

    @validate_arguments
    def cancel_order_with_http_info(
        self,
        order_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="Order ID to cancel. Equity, option or future orderIDs should not include dashes (E.g. `1-2345-6789`). Valid format orderId=`123456789`",
            ),
        ],
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """Cancel Order  # noqa: E501

        Cancels an active order. Request valid for all account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cancel_order_with_http_info(order_id, async_req=True)
        >>> result = thread.get()

        :param order_id: Order ID to cancel. Equity, option or future orderIDs should not include dashes (E.g. `1-2345-6789`). Valid format orderId=`123456789` (required)
        :type order_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrderResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["order_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_order" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["order_id"]:
            _path_params["orderID"] = _params["order_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["Bearer-Token"]  # noqa: E501

        _response_types_map = {
            "200": "OrderResponse",
            "400": "ErrorResponse",
            "401": "ErrorResponse",
            "403": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "503": "ErrorResponse",
            "504": "ErrorResponse",
        }

        return self.api_client.call_api(
            "/v3/orderexecution/orders/{orderID}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def confirm_group_order(
        self,
        order_request: Annotated[
            GroupOrderRequest, Field(..., description="Order request")
        ],
        **kwargs
    ) -> List[OrderConfirmResponses]:  # noqa: E501
        """Confirm Group Order  # noqa: E501

        Creates an Order Confirmation for a group order. Request valid for all account types. Request valid for Order Cancels Order (OCO) and Bracket (BRK) order types as well as grouped orders of other types (NORMAL). All Crypto market orders, excluding USDCUSD, must have `Day` duration (TimeInForce).  #### Order Cancels Order (OCO) An OCO order is a group of orders whereby if one of the orders is filled or partially-filled, then all of the other orders in the group are cancelled.  #### Bracket OCO Orders A bracket order is a special instance of an OCO (Order Cancel Order). Bracket orders are used to exit an existing position. They are designed to limit loss and lock in profit by “bracketing” an order with a simultaneous stop and limit order.  Bracket orders are limited so that the orders are all for the same symbol and are on the same side of the market (either all to sell or all to cover), and they are restricted to closing transactions.  The reason that they follow these rules is because the orders need to be able to auto decrement when a partial fill occurs with one of the orders. For example, if the customer has a sell limit order for 1000 shares and a sell stop order for 1000 shares, and the limit order is partially filled for 500 shares, then the customer would want the stop to remain open, but it should automatically decrement the order to 500 shares to match the remaining open position.  #### Crypto orders - Only one exit bracket can be sent with an entry order in an OSO - Multiple exit brackets can be issued for an open position, as long as the total exit quantity (from all exit orders) does not exceed the crypto balance  #### Note When a group order is submitted, the order execution system treats each sibling order as an individual order. Thus, the system does not validate that each order has the same Quantity, and currently it is not able to update a bracket order as one transaction, instead you must update each order within a bracket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_group_order(order_request, async_req=True)
        >>> result = thread.get()

        :param order_request: Order request (required)
        :type order_request: GroupOrderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OrderConfirmResponses]
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the confirm_group_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.confirm_group_order_with_http_info(
            order_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def confirm_group_order_with_http_info(
        self,
        order_request: Annotated[
            GroupOrderRequest, Field(..., description="Order request")
        ],
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """Confirm Group Order  # noqa: E501

        Creates an Order Confirmation for a group order. Request valid for all account types. Request valid for Order Cancels Order (OCO) and Bracket (BRK) order types as well as grouped orders of other types (NORMAL). All Crypto market orders, excluding USDCUSD, must have `Day` duration (TimeInForce).  #### Order Cancels Order (OCO) An OCO order is a group of orders whereby if one of the orders is filled or partially-filled, then all of the other orders in the group are cancelled.  #### Bracket OCO Orders A bracket order is a special instance of an OCO (Order Cancel Order). Bracket orders are used to exit an existing position. They are designed to limit loss and lock in profit by “bracketing” an order with a simultaneous stop and limit order.  Bracket orders are limited so that the orders are all for the same symbol and are on the same side of the market (either all to sell or all to cover), and they are restricted to closing transactions.  The reason that they follow these rules is because the orders need to be able to auto decrement when a partial fill occurs with one of the orders. For example, if the customer has a sell limit order for 1000 shares and a sell stop order for 1000 shares, and the limit order is partially filled for 500 shares, then the customer would want the stop to remain open, but it should automatically decrement the order to 500 shares to match the remaining open position.  #### Crypto orders - Only one exit bracket can be sent with an entry order in an OSO - Multiple exit brackets can be issued for an open position, as long as the total exit quantity (from all exit orders) does not exceed the crypto balance  #### Note When a group order is submitted, the order execution system treats each sibling order as an individual order. Thus, the system does not validate that each order has the same Quantity, and currently it is not able to update a bracket order as one transaction, instead you must update each order within a bracket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_group_order_with_http_info(order_request, async_req=True)
        >>> result = thread.get()

        :param order_request: Order request (required)
        :type order_request: GroupOrderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OrderConfirmResponses], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["order_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method confirm_group_order" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["order_request"] is not None:
            _body_params = _params["order_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["Bearer-Token"]  # noqa: E501

        _response_types_map = {
            "200": "List[OrderConfirmResponses]",
            "400": "ErrorResponse",
            "401": "ErrorResponse",
            "403": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "503": "ErrorResponse",
            "504": "ErrorResponse",
        }

        return self.api_client.call_api(
            "/v3/orderexecution/ordergroupconfirm",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def confirm_order(
        self,
        order: Annotated[
            Optional[OrderRequest], Field(description="Order Confirmation request.")
        ] = None,
        **kwargs
    ) -> List[OrderConfirmResponses]:  # noqa: E501
        """Confirm Order  # noqa: E501

        Returns estimated cost and commission information for an order without the order actually being placed. Request valid for `Market`, `Limit`, `Stop Market`, `Stop Limit`, `Options`, and `Order Sends Order (OSO)` order types.  All Crypto market orders, excluding USDCUSD, must have `Day` duration (TimeInForce). The fields that are returned in the response depend on the order type. The following shows the different fields that will be returned.  **Base Confirmation**  (All confirmations will have these fields) * Route * Duration * Account * SummaryMessage  **Equity Confirmation** (Base Confirmation fields + the following) * EstimatedPrice * EstimatedPriceDisplay * EstimatedCost * EstimatedCostDisplay * EstimatedCommission * EstimatedCommissionDisplay * DebitCreditEstimatedCost * DebitCreditEstimatedCostDisplay * OrderConfirmId  **Futures Confirmation** (Base Confirmation fields + the following) * ProductCurrency * AccountCurrency * EstimatedCost * EstimatedPrice * EstimatedPriceDisplay * InitialMarginDisplay * EstimatedCommission * EstimatedCommissionDisplay * OrderConfirmId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_order(order, async_req=True)
        >>> result = thread.get()

        :param order: Order Confirmation request.
        :type order: OrderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OrderConfirmResponses]
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the confirm_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.confirm_order_with_http_info(order, **kwargs)  # noqa: E501

    @validate_arguments
    def confirm_order_with_http_info(
        self,
        order: Annotated[
            Optional[OrderRequest], Field(description="Order Confirmation request.")
        ] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """Confirm Order  # noqa: E501

        Returns estimated cost and commission information for an order without the order actually being placed. Request valid for `Market`, `Limit`, `Stop Market`, `Stop Limit`, `Options`, and `Order Sends Order (OSO)` order types.  All Crypto market orders, excluding USDCUSD, must have `Day` duration (TimeInForce). The fields that are returned in the response depend on the order type. The following shows the different fields that will be returned.  **Base Confirmation**  (All confirmations will have these fields) * Route * Duration * Account * SummaryMessage  **Equity Confirmation** (Base Confirmation fields + the following) * EstimatedPrice * EstimatedPriceDisplay * EstimatedCost * EstimatedCostDisplay * EstimatedCommission * EstimatedCommissionDisplay * DebitCreditEstimatedCost * DebitCreditEstimatedCostDisplay * OrderConfirmId  **Futures Confirmation** (Base Confirmation fields + the following) * ProductCurrency * AccountCurrency * EstimatedCost * EstimatedPrice * EstimatedPriceDisplay * InitialMarginDisplay * EstimatedCommission * EstimatedCommissionDisplay * OrderConfirmId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_order_with_http_info(order, async_req=True)
        >>> result = thread.get()

        :param order: Order Confirmation request.
        :type order: OrderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OrderConfirmResponses], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["order"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method confirm_order" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["order"] is not None:
            _body_params = _params["order"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["Bearer-Token"]  # noqa: E501

        _response_types_map = {
            "200": "List[OrderConfirmResponses]",
            "400": "ErrorResponse",
            "401": "ErrorResponse",
            "403": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "503": "ErrorResponse",
            "504": "ErrorResponse",
        }

        return self.api_client.call_api(
            "/v3/orderexecution/orderconfirm",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_activation_triggers(self, **kwargs) -> ActivationTriggers:  # noqa: E501
        """Get Activation Triggers  # noqa: E501

        To place orders with activation triggers, a valid TriggerKey must be sent with the order. This resource provides the available trigger methods with their corresponding key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_activation_triggers(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ActivationTriggers
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the get_activation_triggers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.get_activation_triggers_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def get_activation_triggers_with_http_info(
        self, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """Get Activation Triggers  # noqa: E501

        To place orders with activation triggers, a valid TriggerKey must be sent with the order. This resource provides the available trigger methods with their corresponding key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_activation_triggers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ActivationTriggers, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = []
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_activation_triggers" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["Bearer-Token"]  # noqa: E501

        _response_types_map = {
            "200": "ActivationTriggers",
            "400": "ErrorResponse",
            "401": "ErrorResponse",
            "403": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "503": "ErrorResponse",
            "504": "ErrorResponse",
        }

        return self.api_client.call_api(
            "/v3/orderexecution/activationtriggers",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def place_group_order(
        self,
        order_request: Annotated[
            GroupOrderRequest, Field(..., description="Order request to place.")
        ],
        **kwargs
    ) -> List[OrderResponses]:  # noqa: E501
        """Place Group Order  # noqa: E501

        Submits a group order. Request valid for all account types. Request valid for Order Cancels Order (OCO) and Bracket (BRK) order types as well as grouped orders of other types (NORMAL). All Crypto market orders, excluding USDCUSD, must have `Day` duration (TimeInForce).  #### Order Cancels Order (OCO) An OCO order is a group of orders whereby if one of the orders is filled or partially-filled, then all of the other orders in the group are cancelled.  #### Bracket OCO Orders A bracket order is a special instance of an OCO (Order Cancel Order). Bracket orders are used to exit an existing position. They are designed to limit loss and lock in profit by “bracketing” an order with a simultaneous stop and limit order.  Bracket orders are limited so that the orders are all for the same symbol and are on the same side of the market (either all to sell or all to cover), and they are restricted to closing transactions.  The reason that they follow these rules is because the orders need to be able to auto decrement when a partial fill occurs with one of the orders. For example, if the customer has a sell limit order for 1000 shares and a sell stop order for 1000 shares, and the limit order is partially filled for 500 shares, then the customer would want the stop to remain open, but it should automatically decrement the order to 500 shares to match the remaining open position.  #### Crypto orders - Only one exit bracket can be sent with an entry order in an OSO - Multiple exit brackets can be issued for an open position, as long as the total exit quantity (from all exit orders) does not exceed the crypto balance  #### Note When a group order is submitted, the order execution system treats each sibling order as an individual order. Thus, the system does not validate that each order has the same Quantity, and currently it is not able to update a bracket order as one transaction, instead you must update each order within a bracket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.place_group_order(order_request, async_req=True)
        >>> result = thread.get()

        :param order_request: Order request to place. (required)
        :type order_request: GroupOrderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OrderResponses]
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the place_group_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.place_group_order_with_http_info(
            order_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def place_group_order_with_http_info(
        self,
        order_request: Annotated[
            GroupOrderRequest, Field(..., description="Order request to place.")
        ],
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """Place Group Order  # noqa: E501

        Submits a group order. Request valid for all account types. Request valid for Order Cancels Order (OCO) and Bracket (BRK) order types as well as grouped orders of other types (NORMAL). All Crypto market orders, excluding USDCUSD, must have `Day` duration (TimeInForce).  #### Order Cancels Order (OCO) An OCO order is a group of orders whereby if one of the orders is filled or partially-filled, then all of the other orders in the group are cancelled.  #### Bracket OCO Orders A bracket order is a special instance of an OCO (Order Cancel Order). Bracket orders are used to exit an existing position. They are designed to limit loss and lock in profit by “bracketing” an order with a simultaneous stop and limit order.  Bracket orders are limited so that the orders are all for the same symbol and are on the same side of the market (either all to sell or all to cover), and they are restricted to closing transactions.  The reason that they follow these rules is because the orders need to be able to auto decrement when a partial fill occurs with one of the orders. For example, if the customer has a sell limit order for 1000 shares and a sell stop order for 1000 shares, and the limit order is partially filled for 500 shares, then the customer would want the stop to remain open, but it should automatically decrement the order to 500 shares to match the remaining open position.  #### Crypto orders - Only one exit bracket can be sent with an entry order in an OSO - Multiple exit brackets can be issued for an open position, as long as the total exit quantity (from all exit orders) does not exceed the crypto balance  #### Note When a group order is submitted, the order execution system treats each sibling order as an individual order. Thus, the system does not validate that each order has the same Quantity, and currently it is not able to update a bracket order as one transaction, instead you must update each order within a bracket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.place_group_order_with_http_info(order_request, async_req=True)
        >>> result = thread.get()

        :param order_request: Order request to place. (required)
        :type order_request: GroupOrderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OrderResponses], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["order_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method place_group_order" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["order_request"] is not None:
            _body_params = _params["order_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["Bearer-Token"]  # noqa: E501

        _response_types_map = {
            "200": "List[OrderResponses]",
            "400": "ErrorResponse",
            "401": "ErrorResponse",
            "403": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "503": "ErrorResponse",
            "504": "ErrorResponse",
        }

        return self.api_client.call_api(
            "/v3/orderexecution/ordergroups",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def place_order(
        self,
        order_request: Annotated[
            OrderRequest, Field(..., description="Order to place.")
        ],
        **kwargs
    ) -> typing.Any:  # noqa: E501
        """Place Order  # noqa: E501

        Creates a new brokerage order. Request valid for all account types. Request valid for Market, Limit, Stop Market, Stop Limit, Options and Order Sends Order (OSO) order types. All Crypto market orders, excluding USDCUSD, must have `Day` duration (TimeInForce).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.place_order(order_request, async_req=True)
        >>> result = thread.get()

        :param order_request: Order to place. (required)
        :type order_request: OrderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OrderResponses]
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the place_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.place_order_with_http_info(order_request, **kwargs)  # noqa: E501

    @validate_arguments
    def place_order_with_http_info(
        self,
        order_request: Annotated[
            OrderRequest, Field(..., description="Order to place.")
        ],
        **kwargs
    ) -> typing.Any:  # noqa: E501
        """Place Order  # noqa: E501

        Creates a new brokerage order. Request valid for all account types. Request valid for Market, Limit, Stop Market, Stop Limit, Options and Order Sends Order (OSO) order types. All Crypto market orders, excluding USDCUSD, must have `Day` duration (TimeInForce).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.place_order_with_http_info(order_request, async_req=True)
        >>> result = thread.get()

        :param order_request: Order to place. (required)
        :type order_request: OrderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OrderResponses], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["order_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method place_order" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["order_request"] is not None:
            _body_params = _params["order_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["Bearer-Token"]  # noqa: E501

        _response_types_map = {
            "200": "OrderResponses",
            "400": "ErrorResponse",
            "401": "ErrorResponse",
            "403": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "503": "ErrorResponse",
            "504": "ErrorResponse",
        }

        return self.api_client.call_api(
            "/v3/orderexecution/orders",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def replace_order(
        self,
        order_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="OrderID for order to replace. Equity, option or future orderIDs should not include dashes (E.g. `1-2345-6789`). Valid format orderId=`123456789`",
            ),
        ],
        order_request: Annotated[
            OrderReplaceRequest, Field(..., description="Order to replace.")
        ],
        **kwargs
    ) -> OrderResponse:  # noqa: E501
        """Replace Order  # noqa: E501

        Replaces an active order with a modified version of that order. You cannot update an order that has been filled. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.replace_order(order_id, order_request, async_req=True)
        >>> result = thread.get()

        :param order_id: OrderID for order to replace. Equity, option or future orderIDs should not include dashes (E.g. `1-2345-6789`). Valid format orderId=`123456789` (required)
        :type order_id: str
        :param order_request: Order to replace. (required)
        :type order_request: OrderReplaceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrderResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the replace_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.replace_order_with_http_info(
            order_id, order_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def replace_order_with_http_info(
        self,
        order_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="OrderID for order to replace. Equity, option or future orderIDs should not include dashes (E.g. `1-2345-6789`). Valid format orderId=`123456789`",
            ),
        ],
        order_request: Annotated[
            OrderReplaceRequest, Field(..., description="Order to replace.")
        ],
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """Replace Order  # noqa: E501

        Replaces an active order with a modified version of that order. You cannot update an order that has been filled. Request valid for `Cash`, `Margin`, `Futures`, and `DVP` account types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.replace_order_with_http_info(order_id, order_request, async_req=True)
        >>> result = thread.get()

        :param order_id: OrderID for order to replace. Equity, option or future orderIDs should not include dashes (E.g. `1-2345-6789`). Valid format orderId=`123456789` (required)
        :type order_id: str
        :param order_request: Order to replace. (required)
        :type order_request: OrderReplaceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrderResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["order_id", "order_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_order" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["order_id"]:
            _path_params["orderID"] = _params["order_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["order_request"] is not None:
            _body_params = _params["order_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["Bearer-Token"]  # noqa: E501

        _response_types_map = {
            "200": "OrderResponse",
            "400": "ErrorResponse",
            "401": "ErrorResponse",
            "403": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "503": "ErrorResponse",
            "504": "ErrorResponse",
        }

        return self.api_client.call_api(
            "/v3/orderexecution/orders/{orderID}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def routes(self, **kwargs) -> Routes:  # noqa: E501
        """Get Routes  # noqa: E501

        Returns a list of valid routes that a client can specify when posting an order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.routes(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Routes
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the routes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.routes_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def routes_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Routes  # noqa: E501

        Returns a list of valid routes that a client can specify when posting an order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.routes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Routes, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = []
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'" " to method routes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["Bearer-Token"]  # noqa: E501

        _response_types_map = {
            "200": "Routes",
            "400": "ErrorResponse",
            "401": "ErrorResponse",
            "403": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "503": "ErrorResponse",
            "504": "ErrorResponse",
        }

        return self.api_client.call_api(
            "/v3/orderexecution/routes",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
