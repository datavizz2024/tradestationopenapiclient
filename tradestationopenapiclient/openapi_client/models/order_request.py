# coding: utf-8

"""
    

    # Authentication For more information on authorization and gaining an access/refresh token, please visit: [Authentication](/docs/fundamentals/authentication/auth-overview). <SecurityDefinitions /> 

    The version of the OpenAPI document: 
    Contact: ClientServices@tradestation.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist, constr
from openapi_client.models.advanced_options import AdvancedOptions
from openapi_client.models.order_request_legs import OrderRequestLegs
from openapi_client.models.order_type import OrderType
from openapi_client.models.time_in_force_request import TimeInForceRequest

class OrderRequest(BaseModel):
    """
    Submits 1 or more orders. Crypto order requests require an Account type of `Crypto`.
    """
    account_id: StrictStr = Field(..., alias="AccountID", description="TradeStation Account ID.")
    advanced_options: Optional[AdvancedOptions] = Field(None, alias="AdvancedOptions")
    buying_power_warning: Optional[StrictStr] = Field(None, alias="BuyingPowerWarning", description="For internal use only. For TradeStation Margin accounts enrolled in the Reg-T program, clients should send confirmation that the customer has been shown appropriate buying power warnings in advance of placing an order that could potentially violate the account's buying power. Valid values are: `Enforce`, `Preconfirmed`, and `Confirmed`.")
    legs: Optional[conlist(OrderRequestLegs)] = Field(None, alias="Legs")
    limit_price: Optional[StrictStr] = Field(None, alias="LimitPrice", description="The limit price for this order.")
    osos: Optional[conlist(OrderRequestOSO)] = Field(None, alias="OSOs")
    order_confirm_id: Optional[constr(strict=True, max_length=25, min_length=1)] = Field(None, alias="OrderConfirmID", description="Non-Crypto orders only.  A unique identifier regarding an order used to prevent duplicates. Must be unique per API key, per order, per user.")
    order_type: OrderType = Field(..., alias="OrderType")
    quantity: StrictStr = Field(..., alias="Quantity", description="The quantity of the order.")
    route: Optional[StrictStr] = Field(None, alias="Route", description="The route of the order. For USDCUSD Crypto orders, route must be specified as `USDC`. For all other Crypto currencies, Route will default to `TSSR` if not specified. For Stocks and Options, Route value will default to `Intelligent` if no value is set. Routes can be obtained from [Get Routes](#operation/Routes).")
    stop_price: Optional[StrictStr] = Field(None, alias="StopPrice", description="The stop price for this order. If a TrailingStop amount or percent is passed in with the request (in the AdvancedOptions), and a StopPrice value is also passed in, the StopPrice value is ignored.")
    symbol: StrictStr = Field(..., alias="Symbol", description="The symbol used for this order.")
    time_in_force: TimeInForceRequest = Field(..., alias="TimeInForce")
    trade_action: StrictStr = Field(..., alias="TradeAction", description="TradeAction represents the different trade actions that can be sent to or received from WebAPI. Conveys the intent of the trade: - `BUY` - crypto, equities and futures - `SELL` - crypto, equities and futures - `BUYTOCOVER` - equities - `SELLSHORT` - equities - `BUYTOOPEN` - options - `BUYTOCLOSE` - options - `SELLTOOPEN` - options - `SELLTOCLOSE` - options")
    __properties = ["AccountID", "AdvancedOptions", "BuyingPowerWarning", "Legs", "LimitPrice", "OSOs", "OrderConfirmID", "OrderType", "Quantity", "Route", "StopPrice", "Symbol", "TimeInForce", "TradeAction"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> OrderRequest:
        """Create an instance of OrderRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of advanced_options
        if self.advanced_options:
            _dict['AdvancedOptions'] = self.advanced_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in legs (list)
        _items = []
        if self.legs:
            for _item in self.legs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['Legs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in osos (list)
        _items = []
        if self.osos:
            for _item in self.osos:
                if _item:
                    _items.append(_item.to_dict())
            _dict['OSOs'] = _items
        # override the default output from pydantic by calling `to_dict()` of time_in_force
        if self.time_in_force:
            _dict['TimeInForce'] = self.time_in_force.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> OrderRequest:
        """Create an instance of OrderRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return OrderRequest.parse_obj(obj)

        _obj = OrderRequest.parse_obj({
            "account_id": obj.get("AccountID"),
            "advanced_options": AdvancedOptions.from_dict(obj.get("AdvancedOptions")) if obj.get("AdvancedOptions") is not None else None,
            "buying_power_warning": obj.get("BuyingPowerWarning"),
            "legs": [OrderRequestLegs.from_dict(_item) for _item in obj.get("Legs")] if obj.get("Legs") is not None else None,
            "limit_price": obj.get("LimitPrice"),
            "osos": [OrderRequestOSO.from_dict(_item) for _item in obj.get("OSOs")] if obj.get("OSOs") is not None else None,
            "order_confirm_id": obj.get("OrderConfirmID"),
            "order_type": obj.get("OrderType"),
            "quantity": obj.get("Quantity"),
            "route": obj.get("Route"),
            "stop_price": obj.get("StopPrice"),
            "symbol": obj.get("Symbol"),
            "time_in_force": TimeInForceRequest.from_dict(obj.get("TimeInForce")) if obj.get("TimeInForce") is not None else None,
            "trade_action": obj.get("TradeAction")
        })
        return _obj

from openapi_client.models.order_request_oso import OrderRequestOSO
OrderRequest.update_forward_refs()

