# coding: utf-8

"""
    

    # Authentication For more information on authorization and gaining an access/refresh token, please visit: [Authentication](/docs/fundamentals/authentication/auth-overview). <SecurityDefinitions /> 

    The version of the OpenAPI document: 
    Contact: ClientServices@tradestation.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist
from openapi_client.models.market_activation_rules1 import MarketActivationRules1
from openapi_client.models.order_leg1 import OrderLeg1
from openapi_client.models.order_relationship1 import OrderRelationship1
from openapi_client.models.order_type1 import OrderType1
from openapi_client.models.status1 import Status1
from openapi_client.models.time_activation_rules1 import TimeActivationRules1
from openapi_client.models.trailing_stop1 import TrailingStop1

class Order1(BaseModel):
    """
    A brokerage order.
    """
    account_id: Optional[StrictStr] = Field(None, alias="AccountID", description="TradeStation Account ID.")
    advanced_options: Optional[StrictStr] = Field(None, alias="AdvancedOptions", description="Will display a value when the order has advanced order rules associated with it or is part of a bracket order. Valid Values are: `CND`, `AON`, `TRL`, `SHWQTY`, `DSCPR`, `NON`, `PEGVAL`, `BKO`, `PSO` * `AON` - All or None * `BKO` - Book Only * `CND` - Activation Rule * `DSCPR=<Price>` - Discretionary price * `NON` - Non-Display * `PEGVAL=<Value>` - Peg Value * `PSO` - Add Liquidity * `SHWQTY=<quantity>` - Show Only * `TRL` - Trailing Stop")
    closed_date_time: Optional[datetime] = Field(None, alias="ClosedDateTime", description="The Closed Date Time of this order.")
    commission_fee: Optional[StrictStr] = Field(None, alias="CommissionFee", description="The actual brokerage commission cost and routing fees (if applicable) for a trade based on the number of shares or contracts.")
    conditional_orders: Optional[conlist(OrderRelationship1)] = Field(None, alias="ConditionalOrders", description="Describes the relationship between linked orders in a group and this order.")
    conversion_rate: Optional[StrictStr] = Field(None, alias="ConversionRate", description="Indicates the rate used to convert from the currency of the symbol to the currency of the account.")
    currency: Optional[StrictStr] = Field(None, alias="Currency", description="Currency used to complete the Order.")
    duration: Optional[StrictStr] = Field(None, alias="Duration", description="The amount of time for which an order is valid.")
    filled_price: Optional[StrictStr] = Field(None, alias="FilledPrice", description="At the top level, this is the average fill price. For expanded levels, this is the actual execution price.")
    good_till_date: Optional[datetime] = Field(None, alias="GoodTillDate", description="For GTC, GTC+, GTD and GTD+ order durations. The date the order will expire on in UTC format. The time portion, if \"T00:00:00Z\", should be ignored.")
    group_name: Optional[StrictStr] = Field(None, alias="GroupName", description="It can be used to identify orders that are part of the same bracket.")
    legs: Optional[conlist(OrderLeg1)] = Field(None, alias="Legs", description="An array of legs associated with this order.")
    market_activation_rules: Optional[conlist(MarketActivationRules1)] = Field(None, alias="MarketActivationRules", description="Does not apply to Crypto orders.")
    time_activation_rules: Optional[conlist(TimeActivationRules1)] = Field(None, alias="TimeActivationRules", description="Does not apply to Crypto orders.")
    limit_price: Optional[StrictStr] = Field(None, alias="LimitPrice", description="The limit price for Limit and Stop Limit orders.")
    opened_date_time: Optional[datetime] = Field(None, alias="OpenedDateTime", description="Time the order was placed.")
    order_id: Optional[StrictStr] = Field(None, alias="OrderID", description="The order ID of this order.")
    order_type: Optional[OrderType1] = Field(None, alias="OrderType")
    price_used_for_buying_power: Optional[StrictStr] = Field(None, alias="PriceUsedForBuyingPower", description="Price used for the buying power calculation of the order.")
    reject_reason: Optional[StrictStr] = Field(None, alias="RejectReason", description="If an order has been rejected, this will display the rejection. reason")
    routing: Optional[StrictStr] = Field(None, alias="Routing", description="Identifies the routing selection made by the customer when placing the order.")
    show_only_quantity: Optional[StrictStr] = Field(None, alias="ShowOnlyQuantity", description="Hides the true number of shares intended to be bought or sold. Valid for `Limit`, and `StopLimit` order types. Not valid for all exchanges.")
    spread: Optional[StrictStr] = Field(None, alias="Spread", description="The spread type for an option order.")
    status: Optional[Status1] = Field(None, alias="Status")
    status_description: Optional[StrictStr] = Field(None, alias="StatusDescription", description="Description of the status.")
    stop_price: Optional[StrictStr] = Field(None, alias="StopPrice", description="The stop price for StopLimit and StopMarket orders.")
    trailing_stop: Optional[TrailingStop1] = Field(None, alias="TrailingStop")
    unbundled_route_fee: Optional[StrictStr] = Field(None, alias="UnbundledRouteFee", description="Only applies to equities.  Will contain a value if the order has received a routing fee.")
    __properties = ["AccountID", "AdvancedOptions", "ClosedDateTime", "CommissionFee", "ConditionalOrders", "ConversionRate", "Currency", "Duration", "FilledPrice", "GoodTillDate", "GroupName", "Legs", "MarketActivationRules", "TimeActivationRules", "LimitPrice", "OpenedDateTime", "OrderID", "OrderType", "PriceUsedForBuyingPower", "RejectReason", "Routing", "ShowOnlyQuantity", "Spread", "Status", "StatusDescription", "StopPrice", "TrailingStop", "UnbundledRouteFee"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Order1:
        """Create an instance of Order1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in conditional_orders (list)
        _items = []
        if self.conditional_orders:
            for _item in self.conditional_orders:
                if _item:
                    _items.append(_item.to_dict())
            _dict['ConditionalOrders'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in legs (list)
        _items = []
        if self.legs:
            for _item in self.legs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['Legs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in market_activation_rules (list)
        _items = []
        if self.market_activation_rules:
            for _item in self.market_activation_rules:
                if _item:
                    _items.append(_item.to_dict())
            _dict['MarketActivationRules'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in time_activation_rules (list)
        _items = []
        if self.time_activation_rules:
            for _item in self.time_activation_rules:
                if _item:
                    _items.append(_item.to_dict())
            _dict['TimeActivationRules'] = _items
        # override the default output from pydantic by calling `to_dict()` of trailing_stop
        if self.trailing_stop:
            _dict['TrailingStop'] = self.trailing_stop.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Order1:
        """Create an instance of Order1 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Order1.parse_obj(obj)

        _obj = Order1.parse_obj({
            "account_id": obj.get("AccountID"),
            "advanced_options": obj.get("AdvancedOptions"),
            "closed_date_time": obj.get("ClosedDateTime"),
            "commission_fee": obj.get("CommissionFee"),
            "conditional_orders": [OrderRelationship1.from_dict(_item) for _item in obj.get("ConditionalOrders")] if obj.get("ConditionalOrders") is not None else None,
            "conversion_rate": obj.get("ConversionRate"),
            "currency": obj.get("Currency"),
            "duration": obj.get("Duration"),
            "filled_price": obj.get("FilledPrice"),
            "good_till_date": obj.get("GoodTillDate"),
            "group_name": obj.get("GroupName"),
            "legs": [OrderLeg1.from_dict(_item) for _item in obj.get("Legs")] if obj.get("Legs") is not None else None,
            "market_activation_rules": [MarketActivationRules1.from_dict(_item) for _item in obj.get("MarketActivationRules")] if obj.get("MarketActivationRules") is not None else None,
            "time_activation_rules": [TimeActivationRules1.from_dict(_item) for _item in obj.get("TimeActivationRules")] if obj.get("TimeActivationRules") is not None else None,
            "limit_price": obj.get("LimitPrice"),
            "opened_date_time": obj.get("OpenedDateTime"),
            "order_id": obj.get("OrderID"),
            "order_type": obj.get("OrderType"),
            "price_used_for_buying_power": obj.get("PriceUsedForBuyingPower"),
            "reject_reason": obj.get("RejectReason"),
            "routing": obj.get("Routing"),
            "show_only_quantity": obj.get("ShowOnlyQuantity"),
            "spread": obj.get("Spread"),
            "status": obj.get("Status"),
            "status_description": obj.get("StatusDescription"),
            "stop_price": obj.get("StopPrice"),
            "trailing_stop": TrailingStop1.from_dict(obj.get("TrailingStop")) if obj.get("TrailingStop") is not None else None,
            "unbundled_route_fee": obj.get("UnbundledRouteFee")
        })
        return _obj


