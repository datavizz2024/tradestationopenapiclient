# coding: utf-8

"""
    

    # Authentication For more information on authorization and gaining an access/refresh token, please visit: [Authentication](/docs/fundamentals/authentication/auth-overview). <SecurityDefinitions /> 

    The version of the OpenAPI document: 
    Contact: ClientServices@tradestation.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional, Union
from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, validator

class SymbolSuggestDefinitionInner(BaseModel):
    """
    SymbolSuggestDefinitionInner
    """
    category: Optional[StrictStr] = Field(None, alias="Category", description="The type of financial instrument that the symbol represents, such as a stock, index, or mutual fund.")
    country: Optional[StrictStr] = Field(None, alias="Country", description="The country of the exchange where the symbol is listed.")
    currency: Optional[StrictStr] = Field(None, alias="Currency", description="Displays the type of base currency for the selected symbol.")
    description: Optional[StrictStr] = Field(None, alias="Description", description="Displays the full name of the symbol.")
    display_type: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="DisplayType", description="Symbol's price display type based on the following list:  * `0` \"Automatic\" => .00 (should be handled as 2 decimals) * `1` 0 Decimals => 1 * `2` 1 Decimals => .1 * `3` 2 Decimals => .01 * `4` 3 Decimals => .001 * `5` 4 Decimals => .0001 * `6` 5 Decimals => .00001 * `7` Simplest Fraction * `8` 1/2-Halves => .5 * `9` 1/4-Fourths => .25 * `10` 1/8-Eights => .125 * `11` 1/16-Sixteenths => .0625 * `12` 1/32-ThirtySeconds => .03125 * `13` 1/64-SixtyFourths => .015625 * `14` 1/128-OneTwentyEigths => .0078125 * `15` 1/256-TwoFiftySixths => .003906250 * `16` 10ths and Quarters => .025 * `17` 32nds and Halves => .015625 * `18` 32nds and Quarters => .0078125 * `19` 32nds and Eights => .00390625 * `20` 32nds and Tenths => .003125 * `21` 64ths and Halves => .0078125 * `22` 64ths and Tenths => .0015625 * `23` 6 Decimals => .000001 ")
    error: Optional[StrictStr] = Field(None, alias="Error", description="Element that references error.")
    exchange: Optional[StrictStr] = Field(None, alias="Exchange", description="Name of exchange where this symbol is traded in.")
    exchange_id: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="ExchangeID", description="A unique numerical identifier for the Exchange.")
    expiration_date: Optional[StrictStr] = Field(None, alias="ExpirationDate", description="Displays the expiration date for a futures or options contract in UTC formatted time.")
    expiration_type: Optional[StrictStr] = Field(None, alias="ExpirationType", description="For options only. It indicates whether the option is a monthly, weekly, quarterly or end of month expiration. * W - Weekly * M - Monthly * Q - Quartely * E - End of the month * \"\" - The term not be identified ")
    future_type: Optional[StrictStr] = Field(None, alias="FutureType", description="Displays the type of future contract the symbol represents.")
    min_move: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="MinMove", description="Multiplying factor using the display type to determine the minimum price increment the asset trades in. For options the MinMove may vary. If the MinMove is negative, then the MinMove is dependent on the price. The whole number portion of the min move is the threshold. The leftmost two digits to the right of the decimal (X.XXXX) indicate the min move beneath the threshold, and the rightmost two digits (X.XXXX) indicate the min move above the threshold.")
    name: Optional[StrictStr] = Field(None, alias="Name", description="A unique series of letters assigned to a security for trading purposes.")
    option_type: Optional[StrictStr] = Field(None, alias="OptionType", description="Displays the type of options contract the symbol represents. Valid options include: Puts, Calls.")
    point_value: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="PointValue", description="Symbol`s point value.")
    root: Optional[StrictStr] = Field(None, alias="Root", description="The Symbol root.")
    strike_price: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="StrikePrice", description="Displays strike price of an options contract; For Options symbols only.")
    __properties = ["Category", "Country", "Currency", "Description", "DisplayType", "Error", "Exchange", "ExchangeID", "ExpirationDate", "ExpirationType", "FutureType", "MinMove", "Name", "OptionType", "PointValue", "Root", "StrikePrice"]

    @validator('country')
    def country_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('US', 'DE', 'CA'):
            raise ValueError("must be one of enum values ('US', 'DE', 'CA')")
        return value

    @validator('currency')
    def currency_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('USD', 'AUD', 'CAD', 'CHF', 'DKK', 'EUR', 'DBP', 'HKD', 'JPY', 'NOK', 'NZD', 'SEK', 'SGD'):
            raise ValueError("must be one of enum values ('USD', 'AUD', 'CAD', 'CHF', 'DKK', 'EUR', 'DBP', 'HKD', 'JPY', 'NOK', 'NZD', 'SEK', 'SGD')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> SymbolSuggestDefinitionInner:
        """Create an instance of SymbolSuggestDefinitionInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> SymbolSuggestDefinitionInner:
        """Create an instance of SymbolSuggestDefinitionInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return SymbolSuggestDefinitionInner.parse_obj(obj)

        _obj = SymbolSuggestDefinitionInner.parse_obj({
            "category": obj.get("Category"),
            "country": obj.get("Country"),
            "currency": obj.get("Currency"),
            "description": obj.get("Description"),
            "display_type": obj.get("DisplayType"),
            "error": obj.get("Error"),
            "exchange": obj.get("Exchange"),
            "exchange_id": obj.get("ExchangeID"),
            "expiration_date": obj.get("ExpirationDate"),
            "expiration_type": obj.get("ExpirationType"),
            "future_type": obj.get("FutureType"),
            "min_move": obj.get("MinMove"),
            "name": obj.get("Name"),
            "option_type": obj.get("OptionType"),
            "point_value": obj.get("PointValue"),
            "root": obj.get("Root"),
            "strike_price": obj.get("StrikePrice")
        })
        return _obj


